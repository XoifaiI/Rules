package rules;

import static testing.Testing.*;

import java.time.Duration;
import java.util.Arrays;

public class ArrayRulesExploitTest {

    public static void main(String[] args) {
        entry(() -> {
            describe("Memory & Allocation Exploits", () -> {

                describe("Vector 1: Length overflow / OOM protection", () -> {

                    test("maxLength rejects oversized arrays", () -> {
                        Rule<String[]> rule = ArrayRules.maxLength(100);
                        String[] oversized = new String[101];
                        expect(rule.validate(oversized).isInvalid()).toBe(true);
                    });

                    test("absolute max prevents exteme allocations", () -> {
                        expect(() -> ArrayRules.maxLength(200_000_000)).toThrow();
                    });

                    test("lengthBetween enforces upper bound", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesLengthBetween(0, 1000);
                        expect(rule.validate(new byte[1001]).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 2: Negative length protection", () -> {

                    test("length rejects negative argument", () -> {
                        expect(() -> ArrayRules.length(-1)).toThrow();
                    });

                    test("bytesLength rejects negative argument", () -> {
                        expect(() -> ArrayRules.bytesLength(-1)).toThrow();
                    });

                    test("minLength rejects negative argument", () -> {
                        expect(() -> ArrayRules.minLength(-1)).toThrow();
                    });

                    test("lengthBetween rejects negative min", () -> {
                        expect(() -> ArrayRules.lengthBetween(-1, 10)).toThrow();
                    });
                });

                describe("Vector 3: Integer overflow in offset+length", () -> {

                    test("validRange detects offset+length overflow", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesValidRange(1, Integer.MAX_VALUE);
                        ValidationResult result = rule.validate(new byte[100]);
                        expect(result.isInvalid()).toBe(true);
                        expect(result.message().orElse("")).toContain("overflow");
                    });

                    test("validRange rejects when sum exceeds array length", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesValidRange(50, 60);
                        expect(rule.validate(new byte[100]).isInvalid()).toBe(true);
                    });

                    test("validRange accepts valid range", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesValidRange(10, 50);
                        expect(rule.validate(new byte[100]).isValid()).toBe(true);
                    });

                    test("validDynamicRange catches overflow from untrusted input", () -> {
                        record Request(byte[] data, int offset, int length) {
                        }
                        Rule<Request> rule = ArrayRules.validDynamicRange(
                                Request::data, Request::offset, Request::length);

                        Request attack = new Request(new byte[100], 1, Integer.MAX_VALUE);
                        expect(rule.validate(attack).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 4: Multiplication overflow in allocation", () -> {

                    test("maxLength prevents count*elementSize overflow scenarios", () -> {
                        Rule<int[]> rule = ArrayRules.intsMaxLength(100_000);
                        int[] large = new int[200_000];
                        expect(rule.validate(large).isInvalid()).toBe(true);
                    });
                });
            });

            describe("Reference & Mutability Exploits", () -> {

                describe("Vector 5: Null array protection", () -> {

                    test("notNull rejects null", () -> {
                        Rule<String[]> rule = ArrayRules.notNull();
                        expect(rule.validate(null).isInvalid()).toBe(true);
                    });

                    test("bytesNotNull rejects null", () -> {
                        expect(ArrayRules.bytesNotNull().validate(null).isInvalid()).toBe(true);
                    });

                    test("intsNotNull rejects null", () -> {
                        expect(ArrayRules.intsNotNull().validate(null).isInvalid()).toBe(true);
                    });

                    test("longsNotNull rejects null", () -> {
                        expect(ArrayRules.longsNotNull().validate(null).isInvalid()).toBe(true);
                    });

                    test("doublesNotNull rejects null", () -> {
                        expect(ArrayRules.doublesNotNull().validate(null).isInvalid()).toBe(true);
                    });

                    test("all rules handle null gracefully", () -> {
                        expect(ArrayRules.notEmpty().validate(null).isInvalid()).toBe(true);
                        expect(ArrayRules.length(5).validate(null).isInvalid()).toBe(true);
                        expect(ArrayRules.maxLength(10).validate(null).isInvalid()).toBe(true);
                        expect(ArrayRules.<String>contains("x").validate(null).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 6: Reference aliasing (defensive copy)", () -> {

                    test("secureEquals defensively copies expected at creation", () -> {
                        byte[] original = { 1, 2, 3 };
                        Rule<byte[]> rule = ArrayRules.secureEquals(original);

                        original[0] = 99;

                        expect(rule.validate(new byte[] { 1, 2, 3 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { 99, 2, 3 }).isInvalid()).toBe(true);
                    });

                    test("secureEqualsInts defensively copies expected", () -> {
                        int[] original = { 100, 200, 300 };
                        Rule<int[]> rule = ArrayRules.secureEqualsInts(original);

                        original[0] = 999;

                        expect(rule.validate(new int[] { 100, 200, 300 }).isValid()).toBe(true);
                    });

                    test("secureEqualsLongs defensively copies expected", () -> {
                        long[] original = { Long.MAX_VALUE, Long.MIN_VALUE };
                        Rule<long[]> rule = ArrayRules.secureEqualsLongs(original);

                        original[0] = 0L;

                        expect(rule.validate(new long[] { Long.MAX_VALUE, Long.MIN_VALUE }).isValid()).toBe(true);
                    });

                    test("validateAndCopy returns independent copy", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);

                        String[] original = { "a", "b", "c" };
                        String[] copy = validator.apply(original);

                        original[0] = "modified";

                        expect(copy[0]).toBe("a");
                    });

                    test("validateAndCopyBytes returns independent copy", () -> {
                        var validator = ArrayRules.validateAndCopyBytes(ArrayRules.bytesNotEmpty(), 100);

                        byte[] original = { 1, 2, 3 };
                        byte[] copy = validator.apply(original);

                        original[0] = 99;

                        expect(copy[0]).toBe((byte) 1);
                    });
                });

                describe("Vector 7: TOCTOU protection", () -> {

                    test("validateAndCopy prevents TOCTOU by copying before use", () -> {
                        var validator = ArrayRules.validateAndCopy(
                                ArrayRules.<String>allElements(s -> s != null && !s.isEmpty()
                                        ? ValidationResult.valid()
                                        : ValidationResult.invalid("empty")),
                                100);

                        String[] input = { "valid", "data" };
                        String[] safeCopy = validator.apply(input);

                        input[0] = "";

                        expect(safeCopy[0]).toBe("valid");
                    });
                });

                describe("Vector 8: Shallow clone exposure (deep copy)", () -> {

                    test("deepCopyOf creates independent copies of elements", () -> {
                        StringBuilder[] original = {
                                new StringBuilder("a"),
                                new StringBuilder("b")
                        };

                        StringBuilder[] deep = ArrayRules.deepCopyOf(
                                original,
                                sb -> new StringBuilder(sb.toString()),
                                StringBuilder[]::new);

                        original[0].append("modified");

                        expect(deep[0].toString()).toBe("a");
                    });

                    test("deepCopyOf handles null elements", () -> {
                        String[] withNull = { "a", null, "c" };

                        String[] copy = ArrayRules.deepCopyOf(
                                withNull,
                                s -> new String(s),
                                String[]::new);

                        expect(copy[0]).toBe("a");
                        expect(copy[1]).toBeNull();
                        expect(copy[2]).toBe("c");
                    });
                });

                describe("Vector 9: Malicious clone() override protection", () -> {

                    test("validateAndCopy uses Arrays.copyOf not clone()", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);
                        String[] result = validator.apply(new String[] { "test" });
                        expect(result).never().toBe(null);
                        expect(result[0]).toBe("test");
                    });
                });

                describe("Vector 10: Varargs array exposure", () -> {

                    test("contains does not store reference to element", () -> {
                        String target = "find me";
                        Rule<String[]> rule = ArrayRules.contains(target);
                        expect(rule.validate(new String[] { "find me" }).isValid()).toBe(true);
                    });
                });

                describe("Vector 11: Arrays.asList bidirectional mutation", () -> {

                    test("defensive copy breaks connection to original", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);
                        String[] original = { "a", "b" };
                        String[] copy = validator.apply(original);

                        original[0] = "changed";

                        expect(copy[0]).toBe("a");
                    });
                });
            });

            describe("Type System Exploits", () -> {

                describe("Vector 12: Type confusion via Object[]", () -> {

                    test("isArrayOf validates component type", () -> {
                        Rule<Object> rule = ArrayRules.isArrayOf(String.class);

                        expect(rule.validate(new String[] { "a" }).isValid()).toBe(true);
                        expect(rule.validate(new Integer[] { 1 }).isInvalid()).toBe(true);
                        expect(rule.validate("not an array").isInvalid()).toBe(true);
                    });

                    test("isArrayOf rejects incompatible subtypes", () -> {
                        Rule<Object> rule = ArrayRules.isArrayOf(Integer.class);
                        expect(rule.validate(new Number[] { 1 }).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 13: Covariant array assignment", () -> {

                    test("isArrayOf catches type mismatches at validation time", () -> {
                        Object[] arr = new String[10];
                        Rule<Object> rule = ArrayRules.isArrayOf(Object.class);
                        expect(rule.validate(arr).isValid()).toBe(true);
                    });
                });

                describe("Vector 14: Primitive boxing memory amplification", () -> {

                    test("intsMaxLength prevents large int array processing", () -> {
                        Rule<int[]> rule = ArrayRules.intsMaxLength(10_000);
                        expect(rule.validate(new int[100_000]).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 15: Unsigned byte confusion", () -> {

                    test("bytesInUnsignedRange handles 0-255 range correctly", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesInUnsignedRange(200, 255);

                        expect(rule.validate(new byte[] { (byte) 200 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { (byte) 255 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { (byte) 199 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0 }).isInvalid()).toBe(true);
                    });

                    test("bytesInRange uses signed byte semantics", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesInRange((byte) -10, (byte) 10);

                        expect(rule.validate(new byte[] { -10, 0, 10 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { -11 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 11 }).isInvalid()).toBe(true);
                    });

                    test("isPrintableAscii validates printable range", () -> {
                        Rule<byte[]> rule = ArrayRules.isPrintableAscii();

                        expect(rule.validate("Hello World!".getBytes()).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x00 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x7F }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { (byte) 0xFF }).isInvalid()).toBe(true);
                    });
                });
            });

            describe("Indexing & Bounds Exploits", () -> {

                describe("Vector 16: Off-by-one protection", () -> {

                    test("allElements iterates correctly without off-by-one", () -> {
                        Rule<Integer[]> rule = ArrayRules.allElements(
                                n -> n != null ? ValidationResult.valid() : ValidationResult.invalid("null"));

                        expect(rule.validate(new Integer[] { 1, 2, 3 }).isValid()).toBe(true);
                        expect(rule.validate(new Integer[] { 1, null, 3 }).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 17: Reflection bounds (same protection)", () -> {

                    test("safeLength handles arrays via reflection safely", () -> {
                        expect(ArrayRules.safeLength(new int[5])).toBe(5);
                        expect(ArrayRules.safeLength(new String[3])).toBe(3);
                    });

                    test("safeLength rejects non-arrays", () -> {
                        expect(() -> ArrayRules.safeLength("not an array")).toThrow();
                    });

                    test("safeLength rejects null", () -> {
                        expect(() -> ArrayRules.safeLength(null)).toThrow();
                    });
                });

                describe("Vector 18: Multidimensional null inner arrays", () -> {

                    test("noNullInnerArrays detects null inner arrays", () -> {
                        Rule<String[][]> rule = ArrayRules.noNullInnerArrays();

                        String[][] valid = { { "a" }, { "b" } };
                        String[][] invalid = { { "a" }, null };

                        expect(rule.validate(valid).isValid()).toBe(true);
                        expect(rule.validate(invalid).isInvalid()).toBe(true);
                    });

                    test("isRectangular validates uniform dimensions", () -> {
                        Rule<String[][]> rule = ArrayRules.isRectangular();

                        String[][] rectangular = { { "a", "b" }, { "c", "d" } };
                        String[][] jagged = { { "a", "b" }, { "c" } };
                        String[][] withNull = { { "a" }, null };

                        expect(rule.validate(rectangular).isValid()).toBe(true);
                        expect(rule.validate(jagged).isInvalid()).toBe(true);
                        expect(rule.validate(withNull).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 19: Zero-length edge cases", () -> {

                    test("empty array is valid for allElements (vacuous truth)", () -> {
                        Rule<String> alwaysFail = s -> ValidationResult.invalid("fail");
                        Rule<String[]> rule = ArrayRules.allElements(alwaysFail);
                        expect(rule.validate(new String[0]).isValid()).toBe(true);
                    });

                    test("empty array is invalid for anyElement (no match possible)", () -> {
                        Rule<String> alwaysPass = s -> ValidationResult.valid();
                        Rule<String[]> rule = ArrayRules.anyElement(alwaysPass);
                        expect(rule.validate(new String[0]).isInvalid()).toBe(true);
                    });

                    test("empty array is valid for noElements", () -> {
                        Rule<String> alwaysPass = s -> ValidationResult.valid();
                        Rule<String[]> rule = ArrayRules.noElements(alwaysPass);
                        expect(rule.validate(new String[0]).isValid()).toBe(true);
                    });

                    test("notEmpty rejects zero-length", () -> {
                        expect(ArrayRules.notEmpty().validate(new String[0]).isInvalid()).toBe(true);
                        expect(ArrayRules.bytesNotEmpty().validate(new byte[0]).isInvalid()).toBe(true);
                        expect(ArrayRules.intsNotEmpty().validate(new int[0]).isInvalid()).toBe(true);
                    });

                    test("length(0) accepts zero-length", () -> {
                        expect(ArrayRules.length(0).validate(new String[0]).isValid()).toBe(true);
                    });
                });
            });

            describe("Identity & Equality Exploits", () -> {

                describe("Vector 20: hashCode/equals inconsistency", () -> {

                    test("secureEquals compares content not reference", () -> {
                        byte[] a = { 1, 2, 3 };
                        byte[] b = { 1, 2, 3 };

                        expect(a.equals(b)).toBe(false);

                        Rule<byte[]> rule = ArrayRules.secureEquals(a);
                        expect(rule.validate(b).isValid()).toBe(true);
                    });
                });

                describe("Vector 21: Array in collection identity", () -> {

                    test("contains uses Objects.equals for content comparison", () -> {
                        Rule<String[]> rule = ArrayRules.contains("target");

                        expect(rule.validate(new String[] { "target" }).isValid()).toBe(true);
                        expect(rule.validate(new String[] { "other" }).isInvalid()).toBe(true);
                    });

                    test("bytesContains finds by value not reference", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesContains((byte) 42);

                        expect(rule.validate(new byte[] { 1, 42, 3 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { 1, 2, 3 }).isInvalid()).toBe(true);
                    });

                    test("intsContains finds by value", () -> {
                        Rule<int[]> rule = ArrayRules.intsContains(42);

                        expect(rule.validate(new int[] { 1, 42, 3 }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { 1, 2, 3 }).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 22: Identity equality override", () -> {

                    test("defensive copy prevents attacker equals() override", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);
                        String[] copy = validator.apply(new String[] { "test" });
                        expect(copy).never().toBe(null);
                    });
                });
            });

            describe("Concurrency Exploits", () -> {

                describe("Vector 23-25: Race condition protection", () -> {

                    test("validateAndCopy creates snapshot immune to concurrent modification", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);

                        String[] shared = { "original" };
                        String[] snapshot = validator.apply(shared);

                        shared[0] = "modified by another thread";

                        expect(snapshot[0]).toBe("original");
                    });

                    test("stateful validation respects timeout under heavy load", () -> {
                        ValidationContext ctx = ValidationContext.builder()
                                .timeout(Duration.ofMillis(50))
                                .build();

                        Rule<String> slowRule = s -> {
                            try {
                                Thread.sleep(10);
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                            }
                            return ValidationResult.valid();
                        };

                        Rule<String[]> rule = ArrayRules.allElements(slowRule);
                        String[] large = new String[100];
                        Arrays.fill(large, "test");

                        try {
                            ctx.validateTyped(large, rule);
                            expect(false).toBe(true);
                        } catch (ValidationTimeoutException e) {
                            expect(true).toBe(true);
                        }
                    });
                });
            });

            describe("More Security Vectors", () -> {

                describe("Vector 26: Constant-time length comparison leak", () -> {

                    test("secureEquals timing is independent of match position", () -> {
                        byte[] secret = { 1, 2, 3, 4, 5, 6, 7, 8 };
                        Rule<byte[]> rule = ArrayRules.secureEquals(secret);

                        expect(rule.validate(new byte[] { 0, 2, 3, 4, 5, 6, 7, 8 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 1, 2, 3, 4, 5, 6, 7, 0 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }).isValid()).toBe(true);
                    });

                    test("secureEqualsInts uses MessageDigest for JVM guaranteed constant time", () -> {
                        int[] secret = { Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 12345 };
                        Rule<int[]> rule = ArrayRules.secureEqualsInts(secret);

                        expect(rule.validate(new int[] { 0, Integer.MIN_VALUE, 0, 12345 }).isInvalid()).toBe(true);
                        expect(rule.validate(new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 0 }).isInvalid())
                                .toBe(true);
                        expect(rule.validate(new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 12345 }).isValid())
                                .toBe(true);
                    });

                    test("secureEqualsLongs uses MessageDigest for JVM guaranteed constant time", () -> {
                        long[] secret = { Long.MAX_VALUE, Long.MIN_VALUE, 0L, 123456789L };
                        Rule<long[]> rule = ArrayRules.secureEqualsLongs(secret);

                        expect(rule.validate(new long[] { 0L, Long.MIN_VALUE, 0L, 123456789L }).isInvalid()).toBe(true);
                        expect(rule.validate(new long[] { Long.MAX_VALUE, Long.MIN_VALUE, 0L, 0L }).isInvalid())
                                .toBe(true);
                        expect(rule.validate(new long[] { Long.MAX_VALUE, Long.MIN_VALUE, 0L, 123456789L }).isValid())
                                .toBe(true);
                    });
                });

                describe("Vector 27: Reflection edge cases", () -> {

                    test("safeLength rejects null", () -> {
                        expect(() -> ArrayRules.safeLength(null)).toThrow();
                    });

                    test("safeLength rejects primitive wrappers", () -> {
                        expect(() -> ArrayRules.safeLength(Integer.valueOf(5))).toThrow();
                    });

                    test("safeLength rejects collections", () -> {
                        expect(() -> ArrayRules.safeLength(java.util.Arrays.asList(1, 2, 3))).toThrow();
                    });

                    test("safeLength handles zero-length arrays", () -> {
                        expect(ArrayRules.safeLength(new int[0])).toBe(0);
                        expect(ArrayRules.safeLength(new String[0])).toBe(0);
                        expect(ArrayRules.safeLength(new Object[0])).toBe(0);
                    });

                    test("isArray rejects primitive wrappers", () -> {
                        expect(ArrayRules.isArray(Integer.valueOf(5))).toBe(false);
                        expect(ArrayRules.isArray(Long.valueOf(5L))).toBe(false);
                    });
                });

                describe("Vector 28: Deeply nested array handling", () -> {

                    test("noNullInnerArrays handles many inner arrays", () -> {
                        String[][] large = new String[1000][];
                        for (int i = 0; i < 1000; i++) {
                            large[i] = new String[] { "a" };
                        }
                        expect(ArrayRules.<String>noNullInnerArrays().validate(large).isValid()).toBe(true);
                    });

                    test("isRectangular handles large rectangular arrays", () -> {
                        String[][] rect = new String[100][100];
                        expect(ArrayRules.<String>isRectangular().validate(rect).isValid()).toBe(true);
                    });

                    test("isRectangular detects jaggedness at end", () -> {
                        String[][] jagged = new String[100][];
                        for (int i = 0; i < 99; i++) {
                            jagged[i] = new String[10];
                        }
                        jagged[99] = new String[5];

                        expect(ArrayRules.<String>isRectangular().validate(jagged).isInvalid()).toBe(true);
                    });
                });

                describe("Vector 29: Double/Float special values", () -> {

                    test("doublesInRange handles negative zero", () -> {
                        Rule<double[]> rule = ArrayRules.doublesInRange(-1.0, 1.0);
                        expect(rule.validate(new double[] { -0.0 }).isValid()).toBe(true);
                        expect(rule.validate(new double[] { +0.0 }).isValid()).toBe(true);
                    });

                    test("doublesInRange handles subnormal numbers", () -> {
                        Rule<double[]> rule = ArrayRules.doublesInRange(0.0, 1.0);
                        expect(rule.validate(new double[] { Double.MIN_VALUE }).isValid()).toBe(true);
                        expect(rule.validate(new double[] { Double.MIN_NORMAL }).isValid()).toBe(true);
                    });

                    test("doublesFinite rejects positive infinity", () -> {
                        expect(ArrayRules.doublesFinite().validate(
                                new double[] { Double.POSITIVE_INFINITY }).isInvalid()).toBe(true);
                    });

                    test("doublesFinite rejects negative infinity", () -> {
                        expect(ArrayRules.doublesFinite().validate(
                                new double[] { Double.NEGATIVE_INFINITY }).isInvalid()).toBe(true);
                    });

                    test("doublesInRange with infinity bounds", () -> {
                        expect(() -> ArrayRules.doublesInRange(Double.NEGATIVE_INFINITY, 1.0)).toThrow("bounds cannot be infinite");
                        expect(() -> ArrayRules.doublesInRange(0.0, Double.POSITIVE_INFINITY)).toThrow("bounds cannot be infinite");
                    });
                });

                describe("Vector 30: Integer boundary values", () -> {

                    test("intsInRange handles Integer.MAX_VALUE boundary", () -> {
                        Rule<int[]> rule = ArrayRules.intsInRange(Integer.MAX_VALUE - 10, Integer.MAX_VALUE);
                        expect(rule.validate(new int[] { Integer.MAX_VALUE }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { Integer.MAX_VALUE - 10 }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { Integer.MAX_VALUE - 11 }).isInvalid()).toBe(true);
                    });

                    test("intsInRange handles Integer.MIN_VALUE boundary", () -> {
                        Rule<int[]> rule = ArrayRules.intsInRange(Integer.MIN_VALUE, Integer.MIN_VALUE + 10);
                        expect(rule.validate(new int[] { Integer.MIN_VALUE }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { Integer.MIN_VALUE + 10 }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { Integer.MIN_VALUE + 11 }).isInvalid()).toBe(true);
                    });

                    test("intsInRange handles full range", () -> {
                        Rule<int[]> rule = ArrayRules.intsInRange(Integer.MIN_VALUE, Integer.MAX_VALUE);
                        expect(rule.validate(new int[] { Integer.MIN_VALUE, 0, Integer.MAX_VALUE }).isValid())
                                .toBe(true);
                    });
                });

                describe("Vector 31: Empty array edge cases", () -> {

                    test("allElements on empty array with throwing rule", () -> {
                        Rule<String> throwingRule = s -> {
                            throw new RuntimeException("should not be called");
                        };
                        Rule<String[]> rule = ArrayRules.allElements(throwingRule);
                        expect(rule.validate(new String[0]).isValid()).toBe(true);
                    });

                    test("anyElement on empty array with throwing rule", () -> {
                        Rule<String> throwingRule = s -> {
                            throw new RuntimeException("should not be called");
                        };
                        Rule<String[]> rule = ArrayRules.anyElement(throwingRule);
                        expect(rule.validate(new String[0]).isInvalid()).toBe(true);
                    });

                    test("noElements on empty array with throwing rule", () -> {
                        Rule<String> throwingRule = s -> {
                            throw new RuntimeException("should not be called");
                        };
                        Rule<String[]> rule = ArrayRules.noElements(throwingRule);
                        expect(rule.validate(new String[0]).isValid()).toBe(true);
                    });
                });

                describe("Vector 32: Secure comparison length limits", () -> {

                    test("secureEqualsInts rejects oversized expected", () -> {
                        expect(() -> ArrayRules.secureEqualsInts(new int[1025])).toThrow();
                    });

                    test("secureEqualsInts accepts max size expected", () -> {
                        int[] maxSize = new int[1024];
                        Rule<int[]> rule = ArrayRules.secureEqualsInts(maxSize);
                        expect(rule.validate(maxSize.clone()).isValid()).toBe(true);
                    });

                    test("secureEqualsLongs rejects oversized expected", () -> {
                        expect(() -> ArrayRules.secureEqualsLongs(new long[1025])).toThrow();
                    });

                    test("secureEqualsLongs accepts max size expected", () -> {
                        long[] maxSize = new long[1024];
                        Rule<long[]> rule = ArrayRules.secureEqualsLongs(maxSize);
                        expect(rule.validate(maxSize.clone()).isValid()).toBe(true);
                    });

                    test("secureEqualsInts rejects oversized input", () -> {
                        Rule<int[]> rule = ArrayRules.secureEqualsInts(new int[10]);
                        ValidationResult result = rule.validate(new int[2000]);
                        expect(result.isInvalid()).toBe(true);
                    });

                    test("secureEqualsLongs rejects oversized input", () -> {
                        Rule<long[]> rule = ArrayRules.secureEqualsLongs(new long[10]);
                        ValidationResult result = rule.validate(new long[2000]);
                        expect(result.isInvalid()).toBe(true);
                    });
                });

                describe("Vector 33: Defensive copy independence", () -> {

                    test("validateAndCopy result is independent of original", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);
                        String[] original = { "a", "b", "c" };
                        String[] copy = validator.apply(original);

                        original[0] = "MODIFIED";
                        original[1] = null;

                        expect(copy[0]).toBe("a");
                        expect(copy[1]).toBe("b");
                        expect(copy[2]).toBe("c");
                    });

                    test("validateAndCopy result modification doesn't affect future calls", () -> {
                        var validator = ArrayRules.validateAndCopy(ArrayRules.<String>notEmpty(), 100);
                        String[] original = { "x", "y" };

                        String[] copy1 = validator.apply(original);
                        copy1[0] = "MODIFIED";

                        String[] copy2 = validator.apply(original);
                        expect(copy2[0]).toBe("x");
                    });

                    test("deepCopyOf creates fully independent nested objects", () -> {
                        StringBuilder[] original = {
                                new StringBuilder("first"),
                                new StringBuilder("second"),
                                new StringBuilder("third")
                        };

                        StringBuilder[] deep = ArrayRules.deepCopyOf(
                                original,
                                sb -> new StringBuilder(sb.toString()),
                                StringBuilder[]::new);

                        for (StringBuilder sb : original) {
                            sb.append("_modified");
                        }

                        expect(deep[0].toString()).toBe("first");
                        expect(deep[1].toString()).toBe("second");
                        expect(deep[2].toString()).toBe("third");
                    });
                });

                describe("Vector 34: Byte range edge cases", () -> {

                    test("bytesInUnsignedRange at boundaries", () -> {
                        Rule<byte[]> fullRange = ArrayRules.bytesInUnsignedRange(0, 255);
                        expect(fullRange.validate(new byte[] { 0, (byte) 127, (byte) 128, (byte) 255 }).isValid())
                                .toBe(true);
                    });

                    test("bytesInUnsignedRange single value", () -> {
                        Rule<byte[]> singleValue = ArrayRules.bytesInUnsignedRange(128, 128);
                        expect(singleValue.validate(new byte[] { (byte) 128 }).isValid()).toBe(true);
                        expect(singleValue.validate(new byte[] { (byte) 127 }).isInvalid()).toBe(true);
                        expect(singleValue.validate(new byte[] { (byte) 129 }).isInvalid()).toBe(true);
                    });

                    test("bytesInRange signed boundary", () -> {
                        Rule<byte[]> rule = ArrayRules.bytesInRange(Byte.MIN_VALUE, Byte.MAX_VALUE);
                        expect(rule.validate(new byte[] { Byte.MIN_VALUE, 0, Byte.MAX_VALUE }).isValid()).toBe(true);
                    });

                    test("isPrintableAscii rejects control characters", () -> {
                        Rule<byte[]> rule = ArrayRules.isPrintableAscii();
                        expect(rule.validate(new byte[] { 0x00 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x09 }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x0A }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x0D }).isInvalid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x1F }).isInvalid()).toBe(true);
                    });

                    test("isPrintableAscii accepts space through tilde", () -> {
                        Rule<byte[]> rule = ArrayRules.isPrintableAscii();
                        expect(rule.validate(new byte[] { 0x20 }).isValid()).toBe(true);
                        expect(rule.validate(new byte[] { 0x7E }).isValid()).toBe(true);
                        expect(rule.validate("Hello, World!".getBytes()).isValid()).toBe(true);
                    });
                });

                describe("Vector 35: Dynamic range validation", () -> {

                    test("validDynamicRange rejects negative offset from untrusted input", () -> {
                        record Request(byte[] data, int offset, int length) {
                        }
                        Rule<Request> rule = ArrayRules.validDynamicRange(
                                Request::data, Request::offset, Request::length);

                        Request attack = new Request(new byte[100], -1, 10);
                        expect(rule.validate(attack).isInvalid()).toBe(true);
                    });

                    test("validDynamicRange rejects negative length from untrusted input", () -> {
                        record Request(byte[] data, int offset, int length) {
                        }
                        Rule<Request> rule = ArrayRules.validDynamicRange(
                                Request::data, Request::offset, Request::length);

                        Request attack = new Request(new byte[100], 0, -1);
                        expect(rule.validate(attack).isInvalid()).toBe(true);
                    });

                    test("validDynamicRange accepts valid boundary case", () -> {
                        record Request(byte[] data, int offset, int length) {
                        }
                        Rule<Request> rule = ArrayRules.validDynamicRange(
                                Request::data, Request::offset, Request::length);

                        Request valid = new Request(new byte[100], 0, 100);
                        expect(rule.validate(valid).isValid()).toBe(true);
                    });

                    test("validDynamicRange rejects off-by-one overflow", () -> {
                        record Request(byte[] data, int offset, int length) {
                        }
                        Rule<Request> rule = ArrayRules.validDynamicRange(
                                Request::data, Request::offset, Request::length);

                        Request attack = new Request(new byte[100], 0, 101);
                        expect(rule.validate(attack).isInvalid()).toBe(true);
                    });
                });

            });

            describe("Content Validation", () -> {

                describe("Numeric range validation", () -> {

                    test("intsInRange validates bounds", () -> {
                        Rule<int[]> rule = ArrayRules.intsInRange(-100, 100);

                        expect(rule.validate(new int[] { -100, 0, 100 }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { -101 }).isInvalid()).toBe(true);
                        expect(rule.validate(new int[] { 101 }).isInvalid()).toBe(true);
                    });

                    test("intsNonNegative rejects negative values", () -> {
                        Rule<int[]> rule = ArrayRules.intsNonNegative();

                        expect(rule.validate(new int[] { 0, 1, 100 }).isValid()).toBe(true);
                        expect(rule.validate(new int[] { 0, -1, 100 }).isInvalid()).toBe(true);
                    });

                    test("doublesNotNaN rejects NaN values", () -> {
                        Rule<double[]> rule = ArrayRules.doublesNotNaN();

                        expect(rule.validate(new double[] { 1.0, 2.0, 3.0 }).isValid()).toBe(true);
                        expect(rule.validate(new double[] { 1.0, Double.NaN }).isInvalid()).toBe(true);
                    });

                    test("doublesFinite rejects infinite and NaN", () -> {
                        Rule<double[]> rule = ArrayRules.doublesFinite();

                        expect(rule.validate(new double[] { -1e308, 0, 1e308 }).isValid()).toBe(true);
                        expect(rule.validate(new double[] { Double.POSITIVE_INFINITY }).isInvalid()).toBe(true);
                        expect(rule.validate(new double[] { Double.NEGATIVE_INFINITY }).isInvalid()).toBe(true);
                        expect(rule.validate(new double[] { Double.NaN }).isInvalid()).toBe(true);
                    });

                    test("doublesInRange validates bounds and rejects NaN", () -> {
                        Rule<double[]> rule = ArrayRules.doublesInRange(0.0, 1.0);

                        expect(rule.validate(new double[] { 0.0, 0.5, 1.0 }).isValid()).toBe(true);
                        expect(rule.validate(new double[] { -0.1 }).isInvalid()).toBe(true);
                        expect(rule.validate(new double[] { 1.1 }).isInvalid()).toBe(true);
                        expect(rule.validate(new double[] { Double.NaN }).isInvalid()).toBe(true);
                    });
                });
            });

            describe("Stateful Validation Integration", () -> {

                test("allElements respects collection size limit", () -> {
                    ValidationContext ctx = ValidationContext.builder()
                            .maxCollectionSize(10)
                            .build();

                    Rule<String[]> rule = ArrayRules.allElements(s -> ValidationResult.valid());
                    String[] large = new String[100];

                    ValidationResult result = ctx.validateTyped(large, rule);
                    expect(result.isInvalid()).toBe(true);
                });

                test("allElements tracks depth for nested validation", () -> {
                    ValidationContext ctx = ValidationContext.builder()
                            .maxDepth(2)
                            .build();

                    Rule<Object> deepRule = new Rule<Object>() {
                        @Override
                        public ValidationResult validate(Object value) {
                            return ValidationResult.valid();
                        }

                        @Override
                        public ValidationResult validateWithState(Object value, ValidationState state) {
                            ValidationResult scope = state.enterScope(value);
                            if (scope.isInvalid()) {
                                return scope;
                            }
                            try {
                                if (value instanceof Object[] arr && arr.length > 0 && arr[0] != null) {
                                    return validateWithState(arr[0], state);
                                }
                                return ValidationResult.valid();
                            } finally {
                                state.exitScope(value);
                            }
                        }
                    };

                    Object[] deep = { new Object[] { new Object[] { new Object[] {} } } };

                    ValidationResult result = ctx.validate(deep, (Rule<Object>) deepRule);
                    expect(result.isInvalid()).toBe(true);
                });

                test("allElements detects cycles", () -> {
                    ValidationContext ctx = ValidationContext.builder()
                            .cycleDetection(true)
                            .build();

                    Object[] cycle = new Object[1];
                    cycle[0] = cycle;

                    Rule<Object> cycleRule = new Rule<Object>() {
                        @Override
                        public ValidationResult validate(Object value) {
                            return ValidationResult.valid();
                        }

                        @Override
                        public ValidationResult validateWithState(Object value, ValidationState state) {
                            ValidationResult scope = state.enterScope(value);
                            if (scope.isInvalid()) {
                                return scope;
                            }
                            try {
                                if (value instanceof Object[] arr) {
                                    for (Object elem : arr) {
                                        if (elem != null) {
                                            ValidationResult r = validateWithState(elem, state);
                                            if (r.isInvalid()) {
                                                return r;
                                            }
                                        }
                                    }
                                }
                                return ValidationResult.valid();
                            } finally {
                                state.exitScope(value);
                            }
                        }
                    };

                    ValidationResult result = ctx.validate(cycle, (Rule<Object>) cycleRule);
                    expect(result.isInvalid()).toBe(true);
                });
            });

            describe("Utility Methods", () -> {

                test("isArray correctly identifies arrays", () -> {
                    expect(ArrayRules.isArray(new int[0])).toBe(true);
                    expect(ArrayRules.isArray(new String[0])).toBe(true);
                    expect(ArrayRules.isArray(new int[3][4])).toBe(true);
                    expect(ArrayRules.isArray("not an array")).toBe(false);
                    expect(ArrayRules.isArray(null)).toBe(false);
                    expect(ArrayRules.isArray(123)).toBe(false);
                });

                test("safeLength works for all array types", () -> {
                    expect(ArrayRules.safeLength(new byte[5])).toBe(5);
                    expect(ArrayRules.safeLength(new short[6])).toBe(6);
                    expect(ArrayRules.safeLength(new int[7])).toBe(7);
                    expect(ArrayRules.safeLength(new long[8])).toBe(8);
                    expect(ArrayRules.safeLength(new float[9])).toBe(9);
                    expect(ArrayRules.safeLength(new double[10])).toBe(10);
                    expect(ArrayRules.safeLength(new boolean[11])).toBe(11);
                    expect(ArrayRules.safeLength(new char[12])).toBe(12);
                    expect(ArrayRules.safeLength(new Object[13])).toBe(13);
                });
            });

            describe("Parameter Validation", () -> {

                test("rules reject null elementRule", () -> {
                    expect(() -> ArrayRules.allElements(null)).toThrow();
                    expect(() -> ArrayRules.anyElement(null)).toThrow();
                    expect(() -> ArrayRules.noElements(null)).toThrow();
                });

                test("validateAndCopy rejects null rule", () -> {
                    expect(() -> ArrayRules.validateAndCopy(null, 100)).toThrow();
                });

                test("validateAndCopyBytes rejects null rule", () -> {
                    expect(() -> ArrayRules.validateAndCopyBytes(null, 100)).toThrow();
                });

                test("deepCopyOf rejects null parameters", () -> {
                    expect(() -> ArrayRules.deepCopyOf(null, s -> s, String[]::new)).toThrow();
                    expect(() -> ArrayRules.deepCopyOf(new String[0], null, String[]::new)).toThrow();
                    expect(() -> ArrayRules.deepCopyOf(new String[0], s -> s, null)).toThrow();
                });

                test("isArrayOf rejects null componentType", () -> {
                    expect(() -> ArrayRules.isArrayOf(null)).toThrow();
                });

                test("validRange rejects negative offset", () -> {
                    expect(() -> ArrayRules.validRange(-1, 10)).toThrow();
                });

                test("validRange rejects negative length", () -> {
                    expect(() -> ArrayRules.validRange(0, -1)).toThrow();
                });

                test("bytesInRange rejects min > max", () -> {
                    expect(() -> ArrayRules.bytesInRange((byte) 10, (byte) 5)).toThrow();
                });

                test("bytesInUnsignedRange validates 0-255 bounds", () -> {
                    expect(() -> ArrayRules.bytesInUnsignedRange(-1, 100)).toThrow();
                    expect(() -> ArrayRules.bytesInUnsignedRange(0, 256)).toThrow();
                    expect(() -> ArrayRules.bytesInUnsignedRange(100, 50)).toThrow();
                });

                test("doublesInRange rejects NaN bounds", () -> {
                    expect(() -> ArrayRules.doublesInRange(Double.NaN, 1.0)).toThrow();
                    expect(() -> ArrayRules.doublesInRange(0.0, Double.NaN)).toThrow();
                });
            });

        });
    }
}