package rules;

import static testing.Testing.*;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class CompositeRulesExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("CompositeRules Exploits", () -> {

        describe("CR1 - all() with zero rules", () -> {
          test("all() with empty array returns valid (vacuous truth)", () -> {
            @SuppressWarnings("unchecked")
            Rule<String>[] emptyRules = new Rule[0];
            Rule<String> rule = CompositeRules.all(emptyRules);

            expect(rule.validate("anything").isValid()).toBe(true);
          });

          test("all() with no arguments returns valid", () -> {
            Rule<String> rule = CompositeRules.all();

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate(null).isValid()).toBe(true);
          });

          test("all() is safe from array mutation after creation", () -> {
            @SuppressWarnings("unchecked")
            Rule<String>[] rules = new Rule[] {
                StringRules.notEmpty(),
                StringRules.notBlank()
            };

            Rule<String> rule = CompositeRules.all(rules);

            rules[0] = Rule.alwaysInvalid("evil");

            ValidationResult result = rule.validate("hello");
            expect(result.isValid()).toBe(true);
          });
        });

        describe("CR2 - any() with zero rules", () -> {
          test("any() with empty array returns invalid", () -> {
            @SuppressWarnings("unchecked")
            Rule<String>[] emptyRules = new Rule[0];
            Rule<String> rule = CompositeRules.any(emptyRules);

            expect(rule.validate("anything").isInvalid()).toBe(true);
          });

          test("any() with no arguments returns invalid", () -> {
            Rule<String> rule = CompositeRules.any();

            expect(rule.validate("anything").isInvalid()).toBe(true);
          });
          test("any() firstFailure skips null results", () -> {
            Rule<String> nullRule = value -> null;
            Rule<String> failingRule = Rule.alwaysInvalid("actual failure");

            Rule<String> rule = CompositeRules.any(nullRule, failingRule, nullRule);

            ValidationResult result = rule.validate("test");
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("actual failure");
          });
        });

        describe("CR3 - none() with zero rules", () -> {
          test("none() with empty array returns valid", () -> {
            @SuppressWarnings("unchecked")
            Rule<String>[] emptyRules = new Rule[0];
            Rule<String> rule = CompositeRules.none(emptyRules);

            expect(rule.validate("anything").isValid()).toBe(true);
          });

          test("none() with no arguments returns valid", () -> {
            Rule<String> rule = CompositeRules.none();

            expect(rule.validate("anything").isValid()).toBe(true);
          });

          test("none() treats null result as not matching (passes)", () -> {
            Rule<String> nullRule = value -> null;

            Rule<String> rule = CompositeRules.none(nullRule, nullRule);

            ValidationResult result = rule.validate("test");
            expect(result.isValid()).toBe(true);
          });
        });

        describe("CR4 - Deeply nested composites", () -> {
          test("all() nested 100 levels deep", () -> {
            Rule<String> rule = StringRules.notEmpty();

            for (int i = 0; i < 100; i++) {
              rule = CompositeRules.all(rule);
            }

            expect(rule.validate("hello").isValid()).toBe(true);
            expect(rule.validate("").isInvalid()).toBe(true);
          });

          test("any() nested 100 levels deep", () -> {
            Rule<String> rule = StringRules.notEmpty();

            for (int i = 0; i < 100; i++) {
              rule = CompositeRules.any(rule);
            }

            expect(rule.validate("hello").isValid()).toBe(true);
            expect(rule.validate("").isInvalid()).toBe(true);
          });

          test("mixed nesting all/any/none", () -> {
            Rule<String> rule = StringRules.notEmpty();

            for (int i = 0; i < 30; i++) {
              rule = CompositeRules.all(rule);
              rule = CompositeRules.any(rule);
              rule = CompositeRules.none(Rule.alwaysInvalid("fail"));
              rule = CompositeRules.all(rule);
            }

            expect(rule.validate("hello").isValid()).toBe(true);
          });

          test("all() does not consume depth (no enterScope)", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(50)
                .build();

            Rule<String> rule = StringRules.notEmpty();
            for (int i = 0; i < 100; i++) {
              rule = CompositeRules.all(rule);
            }

            ValidationResult result = ctx.validateTyped("hello", rule);
            expect(result != null).toBe(true);
          });

          test("any() returns first failure message when all fail", () -> {
            Rule<String> rule = CompositeRules.any(
                Rule.alwaysInvalid("first failure"),
                Rule.alwaysInvalid("second failure"),
                Rule.alwaysInvalid("third failure"));

            ValidationResult result = rule.validate("test");
            expect(result.message().orElse("")).toEqual("first failure");
          });
        });

        describe("CR5 - Rule returns null", () -> {
          test("all() treats null-returning rule as invalid", () -> {
            Rule<String> nullRule = value -> null;

            Rule<String> rule = CompositeRules.all(
                StringRules.notEmpty(),
                nullRule);

            ValidationResult result = rule.validate("hello");
            expect(result.isInvalid()).toBe(true);
          });

          test("any() skips null result and continues searching", () -> {
            Rule<String> nullRule = value -> null;

            Rule<String> rule = CompositeRules.any(
                nullRule,
                StringRules.notEmpty());

            ValidationResult result = rule.validate("hello");
            expect(result.isValid()).toBe(true);
          });

          test("any() with all null-returning rules", () -> {
            Rule<String> nullRule = value -> null;

            Rule<String> rule = CompositeRules.any(nullRule, nullRule);

            ValidationResult result = rule.validate("hello");
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("No rules matched");
          });
        });

        describe("CR6 - all() side effects (short-circuit)", () -> {
          test("all() stops on first failure", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> failing = value -> ValidationResult.invalid("fail");

            Rule<String> rule = CompositeRules.all(
                counting,
                failing,
                counting,
                counting);

            rule.validate("test");

            expect(counter.get()).toBe(1);
          });

          test("all() executes all on success", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = CompositeRules.all(
                counting,
                counting,
                counting,
                counting);

            rule.validate("test");

            expect(counter.get()).toBe(4);
          });
        });

        describe("CR7 - any() side effects (short-circuit)", () -> {
          test("any() stops on first success", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.invalid("fail");
            };

            Rule<String> succeeding = value -> ValidationResult.valid();

            Rule<String> rule = CompositeRules.any(
                counting,
                succeeding,
                counting,
                counting);

            rule.validate("test");

            expect(counter.get()).toBe(1);
          });

          test("any() executes all on failure", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.invalid("fail");
            };

            Rule<String> rule = CompositeRules.any(
                counting,
                counting,
                counting,
                counting);

            rule.validate("test");

            expect(counter.get()).toBe(4);
          });
        });

        describe("CR8 - when() condition side effects", () -> {
          test("when() condition evaluated exactly once", () -> {
            AtomicInteger conditionCount = new AtomicInteger(0);
            AtomicInteger thenCount = new AtomicInteger(0);

            Rule<String> condition = value -> {
              conditionCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> thenRule = value -> {
              thenCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = CompositeRules.when(condition, thenRule);

            rule.validate("test");

            expect(conditionCount.get()).toBe(1);
            expect(thenCount.get()).toBe(1);
          });

          test("when() condition false - thenRule not executed", () -> {
            AtomicInteger thenCount = new AtomicInteger(0);

            Rule<String> condition = value -> ValidationResult.invalid("condition false");

            Rule<String> thenRule = value -> {
              thenCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = CompositeRules.when(condition, thenRule);

            ValidationResult result = rule.validate("test");

            expect(result.isValid()).toBe(true);
            expect(thenCount.get()).toBe(0);
          });
        });

        describe("CR9 - when() with null-returning condition", () -> {
          test("when() with null condition treats as false (skips thenRule)", () -> {
            AtomicInteger thenCount = new AtomicInteger(0);

            Rule<String> nullCondition = value -> null;
            Rule<String> thenRule = value -> {
              thenCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = CompositeRules.when(nullCondition, thenRule);

            ValidationResult result = rule.validate("test");
            expect(result.isValid()).toBe(true);
            expect(thenCount.get()).toBe(0);
          });
        });

        describe("CR10 - Complex conditional nesting", () -> {
          test("whenElse correctly branches", () -> {
            AtomicInteger thenCount = new AtomicInteger(0);
            AtomicInteger elseCount = new AtomicInteger(0);

            Rule<String> thenRule = value -> {
              thenCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> elseRule = value -> {
              elseCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> condition = StringRules.startsWith("A");

            Rule<String> rule = CompositeRules.whenElse(condition, thenRule, elseRule);

            rule.validate("Apple");
            expect(thenCount.get()).toBe(1);
            expect(elseCount.get()).toBe(0);

            rule.validate("Banana");
            expect(thenCount.get()).toBe(1);
            expect(elseCount.get()).toBe(1);
          });

          test("nested when/whenElse", () -> {
            Rule<String> innerCondition = StringRules.contains("X");
            Rule<String> innerRule = CompositeRules.whenElse(
                innerCondition,
                Rule.alwaysInvalid("contains X"),
                Rule.alwaysValid());

            Rule<String> outerCondition = StringRules.startsWith("A");
            Rule<String> rule = CompositeRules.whenElse(
                outerCondition,
                innerRule,
                Rule.alwaysValid());

            expect(rule.validate("Apple").isValid()).toBe(true);
            expect(rule.validate("AXE").isInvalid()).toBe(true);
            expect(rule.validate("Banana").isValid()).toBe(true);
            expect(rule.validate("BXX").isValid()).toBe(true);
          });

          test("whenElse() with null condition executes elseRule", () -> {
            AtomicInteger thenCount = new AtomicInteger(0);
            AtomicInteger elseCount = new AtomicInteger(0);

            Rule<String> nullCondition = value -> null;
            Rule<String> thenRule = value -> {
              thenCount.incrementAndGet();
              return ValidationResult.valid();
            };
            Rule<String> elseRule = value -> {
              elseCount.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = CompositeRules.whenElse(nullCondition, thenRule, elseRule);

            ValidationResult result = rule.validate("test");
            expect(result.isValid()).toBe(true);
            expect(thenCount.get()).toBe(0);
            expect(elseCount.get()).toBe(1);
          });
        });

        describe("CR11 - Rule composition via and/or/negate", () -> {
          test("rule.and() short-circuits", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> failing = Rule.alwaysInvalid("fail");
            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = failing.and(counting);

            rule.validate("test");

            expect(counter.get()).toBe(0);
          });

          test("rule.or() short-circuits", () -> {
            AtomicInteger counter = new AtomicInteger(0);

            Rule<String> succeeding = Rule.alwaysValid();
            Rule<String> counting = value -> {
              counter.incrementAndGet();
              return ValidationResult.valid();
            };

            Rule<String> rule = succeeding.or(counting);

            rule.validate("test");

            expect(counter.get()).toBe(0);
          });

          test("negate() inverts result", () -> {
            Rule<String> notEmpty = StringRules.notEmpty();
            Rule<String> isEmpty = notEmpty.negate("Value should be empty");

            expect(isEmpty.validate("").isValid()).toBe(true);
            expect(isEmpty.validate("hello").isInvalid()).toBe(true);
          });

          test("double negate", () -> {
            Rule<String> original = StringRules.notEmpty();
            Rule<String> negated = original.negate("negated");
            Rule<String> doubleNegated = negated.negate("double negated");

            expect(doubleNegated.validate("hello").isValid()).toBe(true);
            expect(doubleNegated.validate("").isInvalid()).toBe(true);
          });
        });

        describe("CR12 - Timeout checking in composite rules", () -> {
          test("all() calls checkTimeout between rules", () -> {
            AtomicInteger checkCount = new AtomicInteger(0);

            Rule<String> countingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                checkCount.incrementAndGet();
                return ValidationResult.valid();
              }
            };

            Rule<String> rule = CompositeRules.all(countingRule, countingRule, countingRule);

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", rule);

            expect(checkCount.get()).toBe(3);
          });

          test("any() calls validateWithState on rules", () -> {
            AtomicInteger callCount = new AtomicInteger(0);

            Rule<String> failingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.invalid("fail");
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                callCount.incrementAndGet();
                return ValidationResult.invalid("fail");
              }
            };

            Rule<String> rule = CompositeRules.any(failingRule, failingRule, failingRule);

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", rule);

            expect(callCount.get()).toBe(3);
          });

          test("when() calls validateWithState on condition", () -> {
            AtomicBoolean conditionCalled = new AtomicBoolean(false);

            Rule<String> condition = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                conditionCalled.set(true);
                return ValidationResult.valid();
              }
            };

            Rule<String> rule = CompositeRules.when(condition, Rule.alwaysValid());

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", rule);

            expect(conditionCalled.get()).toBe(true);
          });
        });

        describe("CR13 - Rule methods delegate to validateWithState", () -> {
          test("and() delegates to validateWithState", () -> {
            AtomicBoolean usedState = new AtomicBoolean(false);

            Rule<String> trackingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                usedState.set(true);
                return ValidationResult.valid();
              }
            };

            Rule<String> combined = Rule.<String>alwaysValid().and(trackingRule);

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", combined);

            expect(usedState.get()).toBe(true);
          });

          test("or() delegates to validateWithState", () -> {
            AtomicBoolean usedState = new AtomicBoolean(false);

            Rule<String> trackingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                usedState.set(true);
                return ValidationResult.valid();
              }
            };

            Rule<String> combined = Rule.<String>alwaysInvalid("fail").or(trackingRule);

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", combined);

            expect(usedState.get()).toBe(true);
          });

          test("negate() delegates to validateWithState", () -> {
            AtomicBoolean usedState = new AtomicBoolean(false);

            Rule<String> trackingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                usedState.set(true);
                return ValidationResult.valid();
              }
            };

            Rule<String> negated = trackingRule.negate("negated");

            ValidationContext ctx = ValidationContext.builder().build();
            ctx.validateTyped("test", negated);

            expect(usedState.get()).toBe(true);
          });
        });

        describe("Null handling", () -> {
          test("all() with null array throws", () -> {
            expect(() -> CompositeRules.all((Rule<Object>[]) null)).toThrow();
          });

          test("all() with null element throws", () -> {
            expect(() -> CompositeRules.all(
                StringRules.notEmpty(),
                null,
                StringRules.notBlank())).toThrow();
          });

          test("any() with null array throws", () -> {
            expect(() -> CompositeRules.any((Rule<Object>[]) null)).toThrow();
          });

          test("none() with null array throws", () -> {
            expect(() -> CompositeRules.none((Rule<Object>[]) null)).toThrow();
          });

          test("when() with null condition throws", () -> {
            expect(() -> CompositeRules.when(null, StringRules.notEmpty())).toThrow();
          });

          test("when() with null thenRule throws", () -> {
            expect(() -> CompositeRules.when(StringRules.notEmpty(), null)).toThrow();
          });

          test("whenElse() with null elseRule throws", () -> {
            expect(() -> CompositeRules.whenElse(
                StringRules.notEmpty(),
                StringRules.notBlank(),
                null)).toThrow();
          });
        });

        describe("Error message propagation", () -> {
          test("all() preserves failure message", () -> {
            Rule<String> rule = CompositeRules.all(
                Rule.alwaysValid(),
                Rule.alwaysValid(),
                Rule.alwaysInvalid("specific failure"),
                Rule.alwaysValid());

            ValidationResult result = rule.validate("test");
            String msg = result.message().orElse("");

            expect(msg.isEmpty()).toBe(false);
            expect(msg).toEqual("specific failure");
          });

          test("none() returns unexpected match message", () -> {
            Rule<String> rule = CompositeRules.none(
                Rule.alwaysInvalid("fail"),
                Rule.alwaysInvalid("fail"),
                Rule.alwaysValid(),
                Rule.alwaysInvalid("fail"));

            ValidationResult result = rule.validate("test");
            String msg = result.message().orElse("");

            expect(msg.isEmpty()).toBe(false);
            expect(msg).toEqual("Unexpected match");
          });
        });
      });
    });
  }
}