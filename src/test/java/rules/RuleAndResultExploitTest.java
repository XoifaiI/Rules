package rules;

import static testing.Testing.*;
import java.util.concurrent.atomic.*;
import java.util.function.Function;

public class RuleAndResultExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("Rule Interface Exploits", () -> {

        describe("R1 - and() with null other", () -> {
          test("and(null) throws NPE", () -> {
            Rule<String> rule = StringRules.notEmpty();

            expect(() -> rule.and(null)).toThrow();
          });

          test("and() with null-returning first rule", () -> {
            Rule<String> nullRule = value -> null;
            Rule<String> second = Rule.alwaysValid();

            Rule<String> combined = nullRule.and(second);
            ValidationResult result = combined.validate("test");

            // null is treated as invalid, short circuits
            expect(result).toBe(null);
          });
        });

        describe("R1b - and() short-circuit correctness", () -> {
          test("and() does not evaluate second if first fails", () -> {
            AtomicBoolean secondCalled = new AtomicBoolean(false);

            Rule<String> first = Rule.alwaysInvalid("first fails");
            Rule<String> second = value -> {
              secondCalled.set(true);
              return ValidationResult.valid();
            };

            Rule<String> combined = first.and(second);
            combined.validate("test");

            expect(secondCalled.get()).toBe(false);
          });

          test("and() evaluates second if first succeeds", () -> {
            AtomicBoolean secondCalled = new AtomicBoolean(false);

            Rule<String> first = Rule.alwaysValid();
            Rule<String> second = value -> {
              secondCalled.set(true);
              return ValidationResult.valid();
            };

            Rule<String> combined = first.and(second);
            combined.validate("test");

            expect(secondCalled.get()).toBe(true);
          });

          test("and() returns first error", () -> {
            Rule<String> first = Rule.alwaysInvalid("first error");
            Rule<String> second = Rule.alwaysInvalid("second error");

            Rule<String> combined = first.and(second);
            ValidationResult result = combined.validate("test");

            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("first error");
          });
        });

        describe("R2 - or() short-circuit correctness", () -> {
          test("or() does not evaluate second if first succeeds", () -> {
            AtomicBoolean secondCalled = new AtomicBoolean(false);

            Rule<String> first = Rule.alwaysValid();
            Rule<String> second = value -> {
              secondCalled.set(true);
              return ValidationResult.valid();
            };

            Rule<String> combined = first.or(second);
            combined.validate("test");

            expect(secondCalled.get()).toBe(false);
          });

          test("or() with null-returning first rule", () -> {
            Rule<String> nullRule = value -> null;
            Rule<String> second = Rule.alwaysValid();

            Rule<String> combined = nullRule.or(second);
            ValidationResult result = combined.validate("test");

            // null is not valid, so second is evaluated
            expect(result.isValid()).toBe(true);
          });

          test("or() evaluates second if first fails", () -> {
            AtomicBoolean secondCalled = new AtomicBoolean(false);

            Rule<String> first = Rule.alwaysInvalid("first fails");
            Rule<String> second = value -> {
              secondCalled.set(true);
              return ValidationResult.valid();
            };

            Rule<String> combined = first.or(second);
            ValidationResult result = combined.validate("test");

            expect(secondCalled.get()).toBe(true);
            expect(result.isValid()).toBe(true);
          });

          test("or() returns first valid result", () -> {
            Rule<String> first = Rule.alwaysInvalid("first fails");
            Rule<String> second = Rule.alwaysValid();

            Rule<String> combined = first.or(second);
            ValidationResult result = combined.validate("test");

            expect(result.isValid()).toBe(true);
          });

          test("or() returns last error if all fail", () -> {
            Rule<String> first = Rule.alwaysInvalid("first error");
            Rule<String> second = Rule.alwaysInvalid("second error");

            Rule<String> combined = first.or(second);
            ValidationResult result = combined.validate("test");

            expect(result.isInvalid()).toBe(true);
            // Returns second (last evaluated) error message
            expect(result.message().orElse("")).toEqual("second error");
          });
        });

        describe("R3 - negate() double negation", () -> {
          test("double negation restores original behavior", () -> {
            Rule<String> original = StringRules.notEmpty();
            Rule<String> negated = original.negate("was not empty");
            Rule<String> doubleNegated = negated.negate("was empty");

            // Original behavior: empty is invalid
            expect(original.validate("hello").isValid()).toBe(true);
            expect(original.validate("").isInvalid()).toBe(true);

            // Negated: empty is valid
            expect(negated.validate("hello").isInvalid()).toBe(true);
            expect(negated.validate("").isValid()).toBe(true);

            // Double negated: empty is invalid again
            expect(doubleNegated.validate("hello").isValid()).toBe(true);
            expect(doubleNegated.validate("").isInvalid()).toBe(true);
          });

          test("triple negation", () -> {
            Rule<String> original = StringRules.notEmpty();
            Rule<String> triple = original
                .negate("msg1")
                .negate("msg2")
                .negate("msg3");

            // Triple = single negation
            expect(triple.validate("hello").isInvalid()).toBe(true);
            expect(triple.validate("").isValid()).toBe(true);
          });

          test("negate(null) throws NPE", () -> {
            Rule<String> rule = StringRules.notEmpty();

            expect(() -> rule.negate(null)).toThrow();
          });
        });

        describe("R4 - compose() with throwing mapper", () -> {
          test("compose() with throwing mapper in failSafe", () -> {
            Function<String, Integer> throwingMapper = s -> {
              throw new RuntimeException("Mapper exploded!");
            };

            Rule<Number> intRule = NumberRules.positive();
            Rule<String> composed = intRule.compose(throwingMapper);

            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .build();

            ValidationResult result = ctx.validateTyped("test", composed);
            expect(result.isInvalid()).toBe(true);
          });

          test("compose() with throwing mapper without failSafe", () -> {
            Function<String, Integer> throwingMapper = s -> {
              throw new RuntimeException("Mapper exploded!");
            };

            Rule<Number> intRule = NumberRules.positive();
            Rule<String> composed = intRule.compose(throwingMapper);

            expect(() -> composed.validate("test")).toThrow();
          });

          test("compose(null) throws NPE", () -> {
            Rule<String> rule = StringRules.notEmpty();

            expect(() -> rule.compose(null)).toThrow();
          });
        });

        describe("R5 - compose() with null-returning mapper", () -> {
          test("compose() with null result is handled", () -> {
            Function<String, Integer> nullMapper = s -> null;

            Rule<Number> intRule = NumberRules.positive();
            Rule<String> composed = intRule.compose(nullMapper);

            // positive().validate(null) should return invalid
            ValidationResult result = composed.validate("test");
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("R6 - test() exception handling", () -> {
          test("test() catches exceptions and returns false", () -> {
            Rule<String> throwingRule = value -> {
              throw new RuntimeException("Validation exploded!");
            };

            boolean result = throwingRule.test("test");
            expect(result).toBe(false);
          });

          test("test() returns true for valid", () -> {
            Rule<String> rule = Rule.alwaysValid();
            expect(rule.test("anything")).toBe(true);
          });

          test("test() returns false for invalid", () -> {
            Rule<String> rule = Rule.alwaysInvalid("fail");
            // test() does NOT catch exceptions by default, but alwaysInvalid returns
            // invalid, it doesn't throw
            expect(rule.test("input")).toBe(false);
          });
        });

        describe("R7 - validate() returns null", () -> {
          test("null-returning rule handled by safeValidate", () -> {
            Rule<String> nullRule = value -> null;

            ValidationResult result = nullRule.safeValidate("test");
            expect(result).toNotBe(null);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Validation returned null");
          });

          test("test() handles null-returning rule", () -> {
            Rule<String> nullRule = value -> null;

            boolean result = nullRule.test("test");
            expect(result).toBe(false);
          });
        });

        describe("R8 - safeValidate() consistency", () -> {
          test("safeValidate() never throws", () -> {
            Rule<String> throwingRule = value -> {
              throw new RuntimeException("boom");
            };

            // Should not throw
            ValidationResult result = throwingRule.safeValidate("test");
            expect(result).toNotBe(null);
            expect(result.isInvalid()).toBe(true);
          });

          test("safeValidate() returns same result as validate() for normal rules", () -> {
            Rule<String> rule = StringRules.notEmpty();

            ValidationResult normal = rule.validate("hello");
            ValidationResult safe = rule.safeValidate("hello");

            expect(normal.isValid()).toBe(safe.isValid());
          });

          test("safeValidate() handles null value", () -> {
            Rule<String> rule = StringRules.notEmpty();

            ValidationResult result = rule.safeValidate(null);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("enforce() behavior", () -> {
          test("enforce() throws for invalid", () -> {
            Rule<String> rule = StringRules.notEmpty();

            expect(() -> rule.enforce("")).toThrow();
          });

          test("enforce() does not throw for valid", () -> {
            Rule<String> rule = StringRules.notEmpty();

            // Should not throw
            rule.enforce("hello");
          });

          test("enforce() throws for null-returning rule", () -> {
            Rule<String> nullRule = value -> null;

            expect(() -> nullRule.enforce("test")).toThrow();
          });

          test("enforce() uses rule's error message", () -> {
            Rule<String> rule = Rule.alwaysInvalid("custom error");

            try {
              rule.enforce("test");
              throw new AssertionError("Should have thrown");
            } catch (ValidationException e) {
              expect(e.getMessage()).toEqual("custom error");
            }
          });

          test("enforce() uses default message for null-returning rule", () -> {
            Rule<String> nullRule = value -> null;

            try {
              nullRule.enforce("test");
              throw new AssertionError("Should have thrown");
            } catch (ValidationException e) {
              expect(e.getMessage()).toEqual("Validation failed");
            }
          });

          test("enforce() exception contains message", () -> {
            Rule<String> rule = StringRules.notEmpty();

            try {
              rule.enforce("");
              throw new AssertionError("Should have thrown");
            } catch (ValidationException e) {
              expect(e.getMessage()).toNotBe(null);
            }
          });
        });

        describe("alwaysValid / alwaysInvalid", () -> {
          test("alwaysValid always returns valid", () -> {
            Rule<String> rule = Rule.alwaysValid();

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate(null).isValid()).toBe(true);
            expect(rule.validate("").isValid()).toBe(true);
          });

          test("alwaysInvalid always returns invalid with message", () -> {
            Rule<String> rule = Rule.alwaysInvalid("custom message");

            expect(rule.validate("anything").isInvalid()).toBe(true);
            expect(rule.validate("anything").message().orElse("")).toEqual("custom message");
          });

          test("alwaysInvalid with null message throws", () -> {
            expect(() -> Rule.alwaysInvalid(null)).toThrow();
          });
        });
      });

      describe("Rule methods with validateWithState", () -> {
        test("and() delegates to validateWithState", () -> {
          AtomicBoolean usedState = new AtomicBoolean(false);

          Rule<String> rule = new Rule<String>() {
            @Override
            public ValidationResult validate(String value) {
              return ValidationResult.valid();
            }

            @Override
            public ValidationResult validateWithState(String value, ValidationState state) {
              usedState.set(true);
              return ValidationResult.valid();
            }
          };

          Rule<String> combined = Rule.<String>alwaysValid().and(rule);

          ValidationContext ctx = ValidationContext.builder().build();
          ctx.validateTyped("test", combined);

          expect(usedState.get()).toBe(true);
        });

        test("or() delegates to validateWithState", () -> {
          AtomicBoolean usedState = new AtomicBoolean(false);

          Rule<String> rule = new Rule<String>() {
            @Override
            public ValidationResult validate(String value) {
              return ValidationResult.valid();
            }

            @Override
            public ValidationResult validateWithState(String value, ValidationState state) {
              usedState.set(true);
              return ValidationResult.valid();
            }
          };

          Rule<String> combined = Rule.<String>alwaysInvalid("fail").or(rule);

          ValidationContext ctx = ValidationContext.builder().build();
          ctx.validateTyped("test", combined);

          expect(usedState.get()).toBe(true);
        });

        test("negate() delegates to validateWithState", () -> {
          AtomicBoolean usedState = new AtomicBoolean(false);

          Rule<String> rule = new Rule<String>() {
            @Override
            public ValidationResult validate(String value) {
              return ValidationResult.valid();
            }

            @Override
            public ValidationResult validateWithState(String value, ValidationState state) {
              usedState.set(true);
              return ValidationResult.valid();
            }
          };

          Rule<String> negated = rule.negate("negated");

          ValidationContext ctx = ValidationContext.builder().build();
          ctx.validateTyped("test", negated);

          expect(usedState.get()).toBe(true);
        });

        test("compose() delegates to validateWithState", () -> {
          AtomicBoolean usedState = new AtomicBoolean(false);

          Rule<Integer> inner = new Rule<Integer>() {
            @Override
            public ValidationResult validate(Integer value) {
              return ValidationResult.valid();
            }

            @Override
            public ValidationResult validateWithState(Integer value, ValidationState state) {
              usedState.set(true);
              return ValidationResult.valid();
            }
          };

          Rule<String> composed = inner.compose(Integer::parseInt);

          ValidationContext ctx = ValidationContext.builder().build();
          ctx.validateTyped("42", composed);

          expect(usedState.get()).toBe(true);
        });
      });

      describe("ValidationResult Exploits", () -> {

        describe("VR1 - Null message in invalid()", () -> {
          test("invalid(null) throws NPE", () -> {
            expect(() -> ValidationResult.invalid(null)).toThrow();
          });
        });

        describe("VR2 - Empty message", () -> {
          test("empty message is allowed", () -> {
            ValidationResult result = ValidationResult.invalid("");

            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("default")).toEqual("");
          });
        });

        describe("VR3 - Very long message", () -> {
          test("very long message is stored correctly", () -> {
            String longMessage = "x".repeat(1_000_000);
            ValidationResult result = ValidationResult.invalid(longMessage);

            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("").length()).toBe(1_000_000);
          });
        });

        describe("VR4 - Message with format specifiers", () -> {
          test("format specifiers are preserved literally", () -> {
            String message = "Value %s is %d%% invalid";
            ValidationResult result = ValidationResult.invalid(message);

            expect(result.message().orElse("")).toEqual(message);
          });

          test("message with newlines", () -> {
            String message = "Line 1\nLine 2\r\nLine 3";
            ValidationResult result = ValidationResult.invalid(message);

            expect(result.message().orElse("")).toEqual(message);
          });

          test("message with unicode", () -> {
            String message = "é”™è¯¯: æ— æ•ˆå€¼ ðŸš«";
            ValidationResult result = ValidationResult.invalid(message);

            expect(result.message().orElse("")).toEqual(message);
          });
        });

        describe("VR5 - and()/or() with null", () -> {
          test("and(null) returns unavailable", () -> {
            ValidationResult valid = ValidationResult.valid();
            ValidationResult result = valid.and(null);

            expect(result).toNotBe(null);
            expect(result.isInvalid()).toBe(true);
          });

          test("or(null) returns this if invalid", () -> {
            ValidationResult invalid = ValidationResult.invalid("error");
            ValidationResult result = invalid.or(null);

            expect(result).toBe(invalid);
          });

          test("or(null) throws NPE", () -> {
            Rule<String> rule = StringRules.notEmpty();

            expect(() -> rule.or(null)).toThrow();
          });

          test("or(null) returns this if valid", () -> {
            ValidationResult valid = ValidationResult.valid();
            ValidationResult result = valid.or(null);

            expect(result).toBe(valid);
          });
        });

        describe("VR6 - systemError()", () -> {
          test("systemError() creates invalid result", () -> {
            ValidationResult result = ValidationResult.systemError("system error");

            expect(result.isInvalid()).toBe(true);
            expect(result.isSystemError()).toBe(true);
            expect(result.message().orElse("")).toEqual("system error");
          });

          test("systemError(null) throws NPE", () -> {
            expect(() -> ValidationResult.systemError(null)).toThrow();
          });

          test("regular invalid is not systemError", () -> {
            ValidationResult result = ValidationResult.invalid("normal error");

            expect(result.isSystemError()).toBe(false);
          });

          test("valid is not systemError", () -> {
            ValidationResult result = ValidationResult.valid();

            expect(result.isSystemError()).toBe(false);
          });

          test("systemError toString includes prefix", () -> {
            ValidationResult result = ValidationResult.systemError("depth exceeded");

            expect(result.toString().contains("SystemError")).toBe(true);
          });

          test("systemError equals considers systemError flag", () -> {
            ValidationResult sys = ValidationResult.systemError("error");
            ValidationResult normal = ValidationResult.invalid("error");

            expect(sys.equals(normal)).toBe(false);
          });
        });

        describe("VR7 - unavailable()", () -> {
          test("unavailable is invalid", () -> {
            ValidationResult result = ValidationResult.unavailable();

            expect(result.isInvalid()).toBe(true);
          });

          test("unavailable has message", () -> {
            ValidationResult result = ValidationResult.unavailable();

            expect(result.message().isPresent()).toBe(true);
            expect(result.message().orElse("")).toEqual("Validation unavailable");
          });

          test("unavailable is not systemError", () -> {
            ValidationResult result = ValidationResult.unavailable();

            expect(result.isSystemError()).toBe(false);
          });
        });

        describe("Chained operations", () -> {
          test("deeply chained and/or", () -> {
            Rule<Number> rule = NumberRules.positive()
                .and(NumberRules.max(100))
                .or(NumberRules.negative().and(NumberRules.min(-100)));

            expect(rule.validate(50).isValid()).toBe(true);
            expect(rule.validate(-50).isValid()).toBe(true);
            expect(rule.validate(0).isInvalid()).toBe(true);
            expect(rule.validate(150).isInvalid()).toBe(true);
            expect(rule.validate(-150).isInvalid()).toBe(true);
          });

          test("compose then and", () -> {
            Rule<Number> positiveInt = NumberRules.positive().and(NumberRules.integer());
            Rule<String> rule = positiveInt.compose(Double::parseDouble);

            expect(rule.validate("42").isValid()).toBe(true);
            expect(rule.validate("42.5").isInvalid()).toBe(true);
            expect(rule.validate("-5").isInvalid()).toBe(true);
          });

          test("negate then and", () -> {
            Rule<String> notEmpty = StringRules.notEmpty();
            Rule<String> isEmpty = notEmpty.negate("is empty");
            Rule<String> isEmptyOrNull = isEmpty.or(ObjectRules.isNull());

            expect(isEmptyOrNull.validate("").isValid()).toBe(true);
            expect(isEmptyOrNull.validate(null).isValid()).toBe(true);
            expect(isEmptyOrNull.validate("x").isInvalid()).toBe(true);
          });

          test("and() chaining", () -> {
            ValidationResult v1 = ValidationResult.valid();
            ValidationResult v2 = ValidationResult.valid();
            ValidationResult i1 = ValidationResult.invalid("error");

            expect(v1.and(v2).isValid()).toBe(true);
            expect(v1.and(i1).isInvalid()).toBe(true);
            expect(i1.and(v1).isInvalid()).toBe(true); // Short circuits
            expect(i1.and(v1).message().orElse("")).toEqual("error");
          });

          test("or() chaining", () -> {
            ValidationResult v1 = ValidationResult.valid();
            ValidationResult i1 = ValidationResult.invalid("error1");
            ValidationResult i2 = ValidationResult.invalid("error2");

            expect(v1.or(i1).isValid()).toBe(true); // Returns first (valid)
            expect(i1.or(v1).isValid()).toBe(true); // Returns second (valid)
            expect(i1.or(i2).isInvalid()).toBe(true);
            expect(i1.or(i2).message().orElse("")).toEqual("error2");
          });
        });

        describe("ValidationResult additional behavior", () -> {
          test("valid() is singleton", () -> {
            ValidationResult v1 = ValidationResult.valid();
            ValidationResult v2 = ValidationResult.valid();

            expect(v1 == v2).toBe(true);
          });

          test("unavailable() is singleton", () -> {
            ValidationResult u1 = ValidationResult.unavailable();
            ValidationResult u2 = ValidationResult.unavailable();

            expect(u1 == u2).toBe(true);
          });

          test("of() factory method", () -> {
            ValidationResult valid = ValidationResult.of(true, "ignored");
            ValidationResult invalid = ValidationResult.of(false, "error message");

            expect(valid.isValid()).toBe(true);
            expect(invalid.isInvalid()).toBe(true);
            expect(invalid.message().orElse("")).toEqual("error message");
          });

          test("messageOrDefault()", () -> {
            ValidationResult valid = ValidationResult.valid();
            ValidationResult invalid = ValidationResult.invalid("actual");

            expect(valid.messageOrDefault("default")).toEqual("default");
            expect(invalid.messageOrDefault("default")).toEqual("actual");
          });

          test("throwIfInvalid()", () -> {
            ValidationResult valid = ValidationResult.valid();
            ValidationResult invalid = ValidationResult.invalid("error");

            valid.throwIfInvalid();
            expect(() -> invalid.throwIfInvalid()).toThrow();
          });

          test("equals() and hashCode()", () -> {
            ValidationResult v1 = ValidationResult.valid();
            ValidationResult v2 = ValidationResult.valid();
            ValidationResult i1 = ValidationResult.invalid("error");
            ValidationResult i2 = ValidationResult.invalid("error");
            ValidationResult i3 = ValidationResult.invalid("different");

            expect(v1.equals(v2)).toBe(true);
            expect(v1.hashCode() == v2.hashCode()).toBe(true);

            expect(i1.equals(i2)).toBe(true);
            expect(i1.hashCode() == i2.hashCode()).toBe(true);

            expect(i1.equals(i3)).toBe(false);
            expect(v1.equals(i1)).toBe(false);
          });

          test("toString()", () -> {
            ValidationResult valid = ValidationResult.valid();
            ValidationResult invalid = ValidationResult.invalid("oops");

            expect(valid.toString()).toEqual("Valid");
            expect(invalid.toString().contains("Invalid")).toBe(true);
            expect(invalid.toString().contains("oops")).toBe(true);
          });
        });
      });
    });
  }
}
