package rules;

import static testing.Testing.*;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class PatternCacheExploitTest {

  private static final int MAX_CACHED_PATTERNS = 256;

  public static void main(String[] args) {
    entry(() -> {
      describe("Pattern Cache Security", () -> {

        describe("Bounded size guarantee", () -> {

          test("cache never exceeds MAX_CACHED_PATTERNS", () -> {
            StringRules.clearPatternCache();

            for (int i = 0; i < 1000; i++) {
              StringRules.matches("pattern" + i);
            }

            int size = StringRules.patternCacheSize();
            expect(size <= MAX_CACHED_PATTERNS).toBe(true);
            System.out.println("Cache size after 1000 patterns: " + size);
          });

          test("cache size stays bounded under repeated access", () -> {
            StringRules.clearPatternCache();

            for (int round = 0; round < 5; round++) {
              for (int i = 0; i < 500; i++) {
                StringRules.matches("pattern" + i);
              }
            }

            int size = StringRules.patternCacheSize();
            expect(size <= MAX_CACHED_PATTERNS).toBe(true);
          });
        });

        describe("Thread safety under high concurrency", () -> {

          test("concurrent access never exceeds cache limit", () -> {
            StringRules.clearPatternCache();
            int threadCount = 100;
            int patternsPerThread = 50;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(threadCount);
            AtomicInteger maxObservedSize = new AtomicInteger(0);

            for (int t = 0; t < threadCount; t++) {
              final int threadId = t;
              executor.submit(() -> {
                try {
                  startLatch.await();

                  for (int i = 0; i < patternsPerThread; i++) {
                    StringRules.matches("thread" + threadId + "_pattern" + i);

                    int currentSize = StringRules.patternCacheSize();
                    maxObservedSize.updateAndGet(max -> Math.max(max, currentSize));
                  }
                } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
                } finally {
                  doneLatch.countDown();
                }
              });
            }

            startLatch.countDown();

            try {
              doneLatch.await(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }

            executor.shutdown();

            int finalSize = StringRules.patternCacheSize();
            System.out.println("Max observed cache size: " + maxObservedSize.get());
            System.out.println("Final cache size: " + finalSize);

            expect(maxObservedSize.get() <= MAX_CACHED_PATTERNS).toBe(true);
            expect(finalSize <= MAX_CACHED_PATTERNS).toBe(true);
          });

          test("cache stampede doesn't cause memory explosion", () -> {
            StringRules.clearPatternCache();
            int threadCount = 1000;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(threadCount);

            for (int t = 0; t < threadCount; t++) {
              final int threadId = t;
              executor.submit(() -> {
                try {
                  startLatch.await();
                  StringRules.matches("stampede_pattern_" + threadId);
                } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
                } finally {
                  doneLatch.countDown();
                }
              });
            }

            Runtime runtime = Runtime.getRuntime();
            runtime.gc();
            long memoryBefore = runtime.totalMemory() - runtime.freeMemory();

            startLatch.countDown();

            try {
              doneLatch.await(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }

            executor.shutdown();

            runtime.gc();
            long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
            long memoryIncrease = memoryAfter - memoryBefore;

            int finalSize = StringRules.patternCacheSize();
            System.out.println("Cache size after stampede: " + finalSize);
            System.out.println("Memory increase: " + (memoryIncrease / 1024) + " KB");

            expect(finalSize <= MAX_CACHED_PATTERNS).toBe(true);

            expect(memoryIncrease < 10_000_000).toBe(true);
          });

          test("concurrent reads and writes are safe", () -> {
            StringRules.clearPatternCache();
            int threadCount = 50;
            int iterations = 100;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch doneLatch = new CountDownLatch(threadCount);
            AtomicInteger exceptions = new AtomicInteger(0);

            for (int i = 0; i < 100; i++) {
              StringRules.matches("prepop" + i);
            }

            for (int t = 0; t < threadCount; t++) {
              final int threadId = t;
              executor.submit(() -> {
                try {
                  for (int i = 0; i < iterations; i++) {
                    if (i % 2 == 0) {
                      StringRules.matches("prepop" + (i % 100));
                    } else {
                      StringRules.matches("new_" + threadId + "_" + i);
                    }
                  }
                } catch (Exception e) {
                  exceptions.incrementAndGet();
                  e.printStackTrace();
                } finally {
                  doneLatch.countDown();
                }
              });
            }

            try {
              doneLatch.await(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }

            executor.shutdown();

            expect(exceptions.get()).toBe(0);

            int finalSize = StringRules.patternCacheSize();
            expect(finalSize <= MAX_CACHED_PATTERNS).toBe(true);
            System.out.println("Final cache size after concurrent access: " + finalSize);
          });
        });

        describe("LRU eviction behavior", () -> {

          test("frequently used patterns stay in cache", () -> {
            StringRules.clearPatternCache();
            StringRules.matches("hot_pattern");

            for (int i = 0; i < 300; i++) {
              StringRules.matches("cold_pattern_" + i);

              if (i % 10 == 0) {
                StringRules.matches("hot_pattern");
              }
            }

            expect(StringRules.patternCacheSize() <= MAX_CACHED_PATTERNS).toBe(true);
          });

          test("clear removes all entries", () -> {
            StringRules.clearPatternCache();
            for (int i = 0; i < 100; i++) {
              StringRules.matches("pattern" + i);
            }

            expect(StringRules.patternCacheSize() > 0).toBe(true);

            StringRules.clearPatternCache();

            expect(StringRules.patternCacheSize()).toBe(0);
          });
        });

        describe("Validation still works correctly", () -> {

          test("matches() returns correct results with cache pressure", () -> {
            StringRules.clearPatternCache();
            Rule<String> emailRule = StringRules.matches("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");

            for (int i = 0; i < 500; i++) {
              StringRules.matches("noise_pattern_" + i);
            }

            expect(emailRule.validate("test@example.com").isValid()).toBe(true);
            expect(emailRule.validate("invalid").isInvalid()).toBe(true);
          });

          test("matchesExactly() works under concurrency", () -> {
            StringRules.clearPatternCache();
            int threadCount = 20;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch doneLatch = new CountDownLatch(threadCount);
            AtomicInteger failures = new AtomicInteger(0);

            Rule<String> numericRule = StringRules.matchesExactly("^\\d+$");

            for (int t = 0; t < threadCount; t++) {
              executor.submit(() -> {
                try {
                  for (int i = 0; i < 100; i++) {
                    if (!numericRule.validate("12345").isValid()) {
                      failures.incrementAndGet();
                    }
                    if (!numericRule.validate("abc").isInvalid()) {
                      failures.incrementAndGet();
                    }
                  }
                } finally {
                  doneLatch.countDown();
                }
              });
            }

            try {
              doneLatch.await(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }

            executor.shutdown();

            expect(failures.get()).toBe(0);
          });
        });
      });
    });
  }
}