package rules;

import static testing.Testing.*;

import java.math.BigDecimal;
import java.math.BigInteger;

public class NumberRulesExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("NumberRules Exploits", () -> {
        describe("N1 - NaN comparisons", () -> {
          test("NaN with between() is invalid", () -> {
            Rule<Number> rule = NumberRules.between(0, 100);

            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("NaN with min() - NaN < min is false", () -> {
            Rule<Number> rule = NumberRules.min(0);

            // NaN >= 0 is false, so should fail
            ValidationResult result = rule.validate(Double.NaN);
            expect(result.isInvalid()).toBe(true);
          });

          test("NaN with max() - NaN > max is false", () -> {
            Rule<Number> rule = NumberRules.max(100);

            // NaN <= 100 is false, so should fail
            ValidationResult result = rule.validate(Double.NaN);
            expect(result.isInvalid()).toBe(true);
          });

          test("NaN with positive()", () -> {
            Rule<Number> rule = NumberRules.positive();

            // NaN > 0 is false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("NaN with negative()", () -> {
            Rule<Number> rule = NumberRules.negative();

            // NaN < 0 is false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("NaN with nonNegative()", () -> {
            Rule<Number> rule = NumberRules.nonNegative();

            // NaN >= 0 is false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("min(NEGATIVE_INFINITY) still rejects NaN", () -> {
            Rule<Number> rule = NumberRules.min(Double.NEGATIVE_INFINITY);

            // NaN >= -Infinity is false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("max(POSITIVE_INFINITY) still rejects NaN", () -> {
            Rule<Number> rule = NumberRules.max(Double.POSITIVE_INFINITY);

            // NaN <= +Infinity is false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("NaN with closeTo()", () -> {
            Rule<Number> rule = NumberRules.closeTo(5.0, 1.0);

            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("Float.NaN behavior", () -> {
            Rule<Number> rule = NumberRules.finite();

            expect(rule.validate(Float.NaN).isInvalid()).toBe(true);
          });

          test("isNaN() rule", () -> {
            Rule<Number> rule = NumberRules.isNaN();

            expect(rule.validate(Double.NaN).isValid()).toBe(true);
            expect(rule.validate(Float.NaN).isValid()).toBe(true);
            expect(rule.validate(5.0).isInvalid()).toBe(true);
          });

          test("notNaN() rule", () -> {
            Rule<Number> rule = NumberRules.notNaN();

            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
            expect(rule.validate(5.0).isValid()).toBe(true);
          });
        });

        describe("N2 - Positive vs Negative zero", () -> {
          test("positive() with -0.0", () -> {
            Rule<Number> rule = NumberRules.positive();

            // -0.0 > 0 is false
            expect(rule.validate(-0.0).isInvalid()).toBe(true);
          });

          test("positive() with +0.0", () -> {
            Rule<Number> rule = NumberRules.positive();

            // +0.0 > 0 is false
            expect(rule.validate(+0.0).isInvalid()).toBe(true);
          });

          test("negative() with -0.0", () -> {
            Rule<Number> rule = NumberRules.negative();

            // -0.0 < 0 is false (they compare equal)
            expect(rule.validate(-0.0).isInvalid()).toBe(true);
          });

          test("nonNegative() with -0.0", () -> {
            Rule<Number> rule = NumberRules.nonNegative();

            // -0.0 >= 0 is true
            expect(rule.validate(-0.0).isValid()).toBe(true);
          });

          test("nonPositive() with +0.0", () -> {
            Rule<Number> rule = NumberRules.nonPositive();

            // +0.0 <= 0 is true
            expect(rule.validate(+0.0).isValid()).toBe(true);
          });

          test("-0.0 equals +0.0 in comparisons", () -> {
            Rule<Number> rule = NumberRules.between(-1, 1);

            expect(rule.validate(-0.0).isValid()).toBe(true);
            expect(rule.validate(+0.0).isValid()).toBe(true);
          });
        });

        describe("N3 - Positive/Negative infinity", () -> {
          test("finite() rejects positive infinity", () -> {
            Rule<Number> rule = NumberRules.finite();

            expect(rule.validate(Double.POSITIVE_INFINITY).isInvalid()).toBe(true);
          });

          test("finite() rejects negative infinity", () -> {
            Rule<Number> rule = NumberRules.finite();

            expect(rule.validate(Double.NEGATIVE_INFINITY).isInvalid()).toBe(true);
          });

          test("isInfinite() accepts infinity", () -> {
            Rule<Number> rule = NumberRules.isInfinite();

            expect(rule.validate(Double.POSITIVE_INFINITY).isValid()).toBe(true);
            expect(rule.validate(Double.NEGATIVE_INFINITY).isValid()).toBe(true);
            expect(rule.validate(5.0).isInvalid()).toBe(true);
          });

          test("positive() with positive infinity", () -> {
            Rule<Number> rule = NumberRules.positive();

            // +Infinity > 0 is true
            expect(rule.validate(Double.POSITIVE_INFINITY).isValid()).toBe(true);
          });

          test("negative() with negative infinity", () -> {
            Rule<Number> rule = NumberRules.negative();

            // -Infinity < 0 is true
            expect(rule.validate(Double.NEGATIVE_INFINITY).isValid()).toBe(true);
          });

          test("max() with positive infinity", () -> {
            Rule<Number> rule = NumberRules.max(Double.MAX_VALUE);

            // +Infinity <= MAX_VALUE is false
            expect(rule.validate(Double.POSITIVE_INFINITY).isInvalid()).toBe(true);
          });

          test("min() with negative infinity", () -> {
            Rule<Number> rule = NumberRules.min(-Double.MAX_VALUE);

            // -Infinity >= -MAX_VALUE is false
            expect(rule.validate(Double.NEGATIVE_INFINITY).isInvalid()).toBe(true);
          });

          test("Float infinity", () -> {
            Rule<Number> rule = NumberRules.finite();

            expect(rule.validate(Float.POSITIVE_INFINITY).isInvalid()).toBe(true);
            expect(rule.validate(Float.NEGATIVE_INFINITY).isInvalid()).toBe(true);
          });
        });

        describe("N4 - Subnormal numbers", () -> {
          test("Double.MIN_VALUE (smallest positive)", () -> {
            Rule<Number> rule = NumberRules.positive();

            // Double.MIN_VALUE is the smallest positive value
            expect(rule.validate(Double.MIN_VALUE).isValid()).toBe(true);
          });

          test("Double.MIN_NORMAL", () -> {
            Rule<Number> rule = NumberRules.positive();

            expect(rule.validate(Double.MIN_NORMAL).isValid()).toBe(true);
          });

          test("subnormal in range", () -> {
            Rule<Number> rule = NumberRules.between(0, 1e-300);

            expect(rule.validate(Double.MIN_VALUE).isValid()).toBe(true);
            expect(rule.validate(Double.MIN_NORMAL).isValid()).toBe(true);
          });

          test("negative subnormal", () -> {
            Rule<Number> rule = NumberRules.negative();

            expect(rule.validate(-Double.MIN_VALUE).isValid()).toBe(true);
          });

          test("closeTo with subnormal epsilon", () -> {
            Rule<Number> rule = NumberRules.closeTo(0, Double.MIN_VALUE);

            expect(rule.validate(0.0).isValid()).toBe(true);
            expect(rule.validate(Double.MIN_VALUE).isValid()).toBe(true);
          });
        });

        describe("N5 - Precision loss in closeTo()", () -> {
          test("0.1 + 0.2 != 0.3 exactly", () -> {
            double sum = 0.1 + 0.2;

            Rule<Number> exact = NumberRules.closeTo(0.3, 0.0);
            Rule<Number> tolerant = NumberRules.closeTo(0.3, 1e-10);

            // Exact comparison fails due to floating point
            expect(exact.validate(sum).isInvalid()).toBe(true);
            // With tolerance it passes
            expect(tolerant.validate(sum).isValid()).toBe(true);
          });

          test("repeated addition accumulates error", () -> {
            double sum = 0.0;
            for (int i = 0; i < 10; i++) {
              sum += 0.1;
            }

            Rule<Number> exact = NumberRules.closeTo(1.0, 0.0);
            Rule<Number> tolerant = NumberRules.closeTo(1.0, 1e-10);

            expect(exact.validate(sum).isInvalid()).toBe(true);
            expect(tolerant.validate(sum).isValid()).toBe(true);
          });

          test("large number precision", () -> {
            double large = 1e15;
            double largePlus1 = large + 1;

            // At this scale, +1 might not be representable
            Rule<Number> rule = NumberRules.closeTo(large, 0.5);

            // This depends on whether large + 1 can be represented
            ValidationResult result = rule.validate(largePlus1);
            // Should work since 1e15 + 1 is representable
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("N6 - Integer overflow via doubleValue()", () -> {
          test("Long.MAX_VALUE precision loss is expected library behavior", () -> {
            // Long.MAX_VALUE = 9223372036854775807
            // As double: 9223372036854775808.0 (rounded)
            // Long.MAX_VALUE - 1 as double is the same value due to precision loss

            // show they map to the same double
            double maxAsDouble = ((Number) Long.MAX_VALUE).doubleValue();
            double maxMinus1AsDouble = ((Number) (Long.MAX_VALUE - 1)).doubleValue();
            expect(maxAsDouble == maxMinus1AsDouble).toBe(true);

            // Because of precision loss, a rule using Long.MAX_VALUE - 1 as max
            // will accept Long.MAX_VALUE (they're the same double value)
            Rule<Number> rule = NumberRules.between(0, Long.MAX_VALUE - 1);
            expect(rule.validate(Long.MAX_VALUE).isValid()).toBe(true);
          });

          test("Long.MIN_VALUE as double", () -> {
            Rule<Number> rule = NumberRules.negative();

            expect(rule.validate(Long.MIN_VALUE).isValid()).toBe(true);
          });

          test("large Long in range check", () -> {
            // Two different Longs that map to same double
            long l1 = Long.MAX_VALUE;
            long l2 = Long.MAX_VALUE - 1;

            Rule<Number> rule = NumberRules.positive();

            expect(rule.validate(l1).isValid()).toBe(true);
            expect(rule.validate(l2).isValid()).toBe(true);
          });
        });

        describe("N7 - BigDecimal precision loss", () -> {
          test("BigDecimal with many digits loses precision as double", () -> {
            BigDecimal bd = new BigDecimal("9999999999999999999.999999999");
            double d = bd.doubleValue();

            // The BigDecimal has fractional digits, but as double they're lost
            BigDecimal roundTrip = BigDecimal.valueOf(d);
            expect(roundTrip.compareTo(bd) != 0).toBe(true);

            // Rule still works on the BigDecimal (uses doubleValue internally)
            Rule<Number> rule = NumberRules.positive();
            expect(rule.validate(bd).isValid()).toBe(true);
          });

          test("BigDecimal very small number", () -> {
            BigDecimal bd = new BigDecimal("0.0000000000000000000001");

            Rule<Number> rule = NumberRules.positive();

            expect(rule.validate(bd).isValid()).toBe(true);
          });

          test("BigInteger as Number", () -> {
            BigInteger bi = new BigInteger("99999999999999999999999999999999");

            Rule<Number> rule = NumberRules.positive();

            // BigInteger.doubleValue() returns Infinity for huge values
            expect(rule.validate(bi).isValid()).toBe(true);
          });

          test("BigInteger too large becomes Infinity", () -> {
            // Create a number larger than Double.MAX_VALUE
            BigInteger huge = BigInteger.TEN.pow(400);

            Rule<Number> rule = NumberRules.finite();

            // doubleValue() returns Infinity
            expect(rule.validate(huge).isInvalid()).toBe(true);
          });
        });

        describe("N8 - Hexadecimal float edge cases", () -> {
          test("signaling NaN", () -> {
            // Create a signaling NaN (may become quiet NaN in Java)
            float snan = Float.intBitsToFloat(0x7f800001);

            Rule<Number> rule = NumberRules.finite();

            // Any NaN should be rejected
            expect(rule.validate(snan).isInvalid()).toBe(true);
          });

          test("quiet NaN", () -> {
            float qnan = Float.intBitsToFloat(0x7fc00000);

            Rule<Number> rule = NumberRules.isNaN();

            expect(rule.validate(qnan).isValid()).toBe(true);
          });

          test("denormalized float", () -> {
            float denorm = Float.intBitsToFloat(0x00000001);

            Rule<Number> rule = NumberRules.positive();

            expect(rule.validate(denorm).isValid()).toBe(true);
          });

          test("negative zero via bits", () -> {
            float negZero = Float.intBitsToFloat(0x80000000);

            Rule<Number> rule = NumberRules.nonNegative();

            // -0.0f >= 0 is true
            expect(rule.validate(negZero).isValid()).toBe(true);
          });
        });

        describe("N9 - Range with infinity bounds", () -> {
          test("between with infinity bounds", () -> {
            Rule<Number> rule = NumberRules.between(
                Double.NEGATIVE_INFINITY,
                Double.POSITIVE_INFINITY);

            // Any finite number should pass
            expect(rule.validate(0.0).isValid()).toBe(true);
            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(-Double.MAX_VALUE).isValid()).toBe(true);

            // Infinity itself should pass
            expect(rule.validate(Double.POSITIVE_INFINITY).isValid()).toBe(true);
            expect(rule.validate(Double.NEGATIVE_INFINITY).isValid()).toBe(true);

            // But NaN should fail
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });

          test("min with negative infinity", () -> {
            Rule<Number> rule = NumberRules.min(Double.NEGATIVE_INFINITY);

            // Everything >= -Infinity
            expect(rule.validate(Double.NEGATIVE_INFINITY).isValid()).toBe(true);
            expect(rule.validate(-Double.MAX_VALUE).isValid()).toBe(true);
          });

          test("max with positive infinity", () -> {
            Rule<Number> rule = NumberRules.max(Double.POSITIVE_INFINITY);

            // Everything <= +Infinity
            expect(rule.validate(Double.POSITIVE_INFINITY).isValid()).toBe(true);
            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
          });
        });

        describe("N10 - Exclusive range at boundary", () -> {
          test("betweenExclusive at lower boundary", () -> {
            Rule<Number> rule = NumberRules.betweenExclusive(1.0, 10.0);

            expect(rule.validate(1.0).isInvalid()).toBe(true);
            expect(rule.validate(1.0000001).isValid()).toBe(true);
          });

          test("betweenExclusive at upper boundary", () -> {
            Rule<Number> rule = NumberRules.betweenExclusive(1.0, 10.0);

            expect(rule.validate(10.0).isInvalid()).toBe(true);
            expect(rule.validate(9.9999999).isValid()).toBe(true);
          });

          test("betweenExclusive exactly in middle", () -> {
            Rule<Number> rule = NumberRules.betweenExclusive(1.0, 10.0);

            expect(rule.validate(5.5).isValid()).toBe(true);
          });

          test("betweenExclusive with NaN min throws", () -> {
            expect(() -> NumberRules.betweenExclusive(Double.NaN, 10))
                .toThrow("bounds cannot be NaN");
          });

          test("betweenExclusive with NaN max throws", () -> {
            expect(() -> NumberRules.betweenExclusive(0, Double.NaN))
                .toThrow("bounds cannot be NaN");
          });

          test("betweenExclusive rejects NaN input", () -> {
            Rule<Number> rule = NumberRules.betweenExclusive(0, 10);

            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
            expect(rule.validate(Double.NaN).message().orElse("")).toEqual("Value is NaN");
          });

          test("betweenExclusive rejects null", () -> {
            Rule<Number> rule = NumberRules.betweenExclusive(0, 10);

            expect(rule.validate(null).isInvalid()).toBe(true);
            expect(rule.validate(null).message().orElse("")).toEqual("Value is null");
          });

          test("between (inclusive) at boundaries", () -> {
            Rule<Number> rule = NumberRules.between(1.0, 10.0);

            expect(rule.validate(1.0).isValid()).toBe(true);
            expect(rule.validate(10.0).isValid()).toBe(true);
          });
        });

        describe("N11 - min/max with infinity", () -> {
          test("min(NEGATIVE_INFINITY) accepts everything (except NaN)", () -> {
            Rule<Number> rule = NumberRules.min(Double.NEGATIVE_INFINITY);

            expect(rule.validate(-Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(0).isValid()).toBe(true);
            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(Double.NEGATIVE_INFINITY).isValid()).toBe(true);
          });

          test("max(POSITIVE_INFINITY) accepts everything (except NaN)", () -> {
            Rule<Number> rule = NumberRules.max(Double.POSITIVE_INFINITY);

            expect(rule.validate(-Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(0).isValid()).toBe(true);
            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(Double.POSITIVE_INFINITY).isValid()).toBe(true);
          });
        });

        describe("N12 - Overflow in closeTo calculation", () -> {
          test("closeTo with MAX_VALUE target and large value", () -> {
            Rule<Number> rule = NumberRules.closeTo(Double.MAX_VALUE, 1.0);

            // MAX_VALUE - MAX_VALUE = 0, within epsilon
            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
          });

          test("closeTo with extreme difference", () -> {
            Rule<Number> rule = NumberRules.closeTo(Double.MAX_VALUE, 1.0);

            // -MAX_VALUE to MAX_VALUE difference would overflow if not careful
            // Math.abs(MAX_VALUE - (-MAX_VALUE)) = Infinity
            expect(rule.validate(-Double.MAX_VALUE).isInvalid()).toBe(true);
          });

          test("closeTo with infinity target throws IllegalArgumentException", () -> {
            expect(() -> NumberRules.closeTo(Double.POSITIVE_INFINITY, 1.0))
                .toThrow("target cannot be infinite");
          });

          test("closeTo with NaN target throws", () -> {
            expect(() -> NumberRules.closeTo(Double.NaN, 1.0))
                .toThrow();
          });

          test("closeTo with NaN epsilon throws", () -> {
            expect(() -> NumberRules.closeTo(5.0, Double.NaN))
                .toThrow();
          });

          test("closeTo with negative epsilon throws", () -> {
            expect(() -> NumberRules.closeTo(5.0, -1.0))
                .toThrow();
          });

          test("closeTo with zero epsilon", () -> {
            Rule<Number> rule = NumberRules.closeTo(5.0, 0.0);

            expect(rule.validate(5.0).isValid()).toBe(true);
            expect(rule.validate(5.0000001).isInvalid()).toBe(true);
          });

          test("closeTo with infinite epsilon accepts everything finite", () -> {
            Rule<Number> rule = NumberRules.closeTo(0, Double.POSITIVE_INFINITY);

            expect(rule.validate(Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(-Double.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(0).isValid()).toBe(true);
            // NaN still fails because Math.abs(0 - NaN) is NaN, and NaN <= Infinity is
            // false
            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
          });
        });

        describe("Error messages", () -> {
          test("finite() NaN message", () -> {
            ValidationResult result = NumberRules.finite().validate(Double.NaN);
            expect(result.message().orElse("")).toEqual("Value is NaN");
          });

          test("finite() infinity message", () -> {
            ValidationResult result = NumberRules.finite().validate(Double.POSITIVE_INFINITY);
            expect(result.message().orElse("")).toEqual("Value is infinite");
          });

          test("positive() message", () -> {
            ValidationResult result = NumberRules.positive().validate(-5);
            expect(result.message().orElse("")).toEqual("Value is not positive");
          });

          test("negative() message", () -> {
            ValidationResult result = NumberRules.negative().validate(5);
            expect(result.message().orElse("")).toEqual("Value is not negative");
          });

          test("nonNegative() message", () -> {
            ValidationResult result = NumberRules.nonNegative().validate(-5);
            expect(result.message().orElse("")).toEqual("Value is negative");
          });

          test("nonPositive() message", () -> {
            ValidationResult result = NumberRules.nonPositive().validate(5);
            expect(result.message().orElse("")).toEqual("Value is positive");
          });

          test("between() message", () -> {
            ValidationResult result = NumberRules.between(0, 10).validate(15);
            expect(result.message().orElse("")).toEqual("Value is out of range");
          });

          test("min() message", () -> {
            ValidationResult result = NumberRules.min(10).validate(5);
            expect(result.message().orElse("")).toEqual("Value is below minimum");
          });

          test("max() message", () -> {
            ValidationResult result = NumberRules.max(10).validate(15);
            expect(result.message().orElse("")).toEqual("Value exceeds maximum");
          });

          test("closeTo() message", () -> {
            ValidationResult result = NumberRules.closeTo(5, 1).validate(10);
            expect(result.message().orElse("")).toEqual("Value is not close enough to target");
          });

          test("integer() non-finite message", () -> {
            ValidationResult result = NumberRules.integer().validate(Double.POSITIVE_INFINITY);
            expect(result.message().orElse("")).toEqual("Value must be finite");
          });

          test("integer() fractional message", () -> {
            ValidationResult result = NumberRules.integer().validate(5.5);
            expect(result.message().orElse("")).toEqual("Value is not an integer");
          });

          test("isNaN() message", () -> {
            ValidationResult result = NumberRules.isNaN().validate(5.0);
            expect(result.message().orElse("")).toEqual("Value is not NaN");
          });

          test("isInfinite() message", () -> {
            ValidationResult result = NumberRules.isInfinite().validate(5.0);
            expect(result.message().orElse("")).toEqual("Value is not infinite");
          });
        });

        describe("Null handling", () -> {
          test("all rules reject null", () -> {
            expect(NumberRules.finite().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.notNaN().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.isNaN().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.isInfinite().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.integer().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.positive().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.negative().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.nonNegative().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.nonPositive().validate(null).isInvalid()).toBe(true);
            expect(NumberRules.between(0, 10).validate(null).isInvalid()).toBe(true);
            expect(NumberRules.min(0).validate(null).isInvalid()).toBe(true);
            expect(NumberRules.max(10).validate(null).isInvalid()).toBe(true);
            expect(NumberRules.closeTo(5, 1).validate(null).isInvalid()).toBe(true);
          });
        });

        describe("Constructor validation", () -> {
          test("between with NaN min throws", () -> {
            expect(() -> NumberRules.between(Double.NaN, 10)).toThrow();
          });

          test("between with NaN max throws", () -> {
            expect(() -> NumberRules.between(0, Double.NaN)).toThrow();
          });

          test("between with min > max throws", () -> {
            expect(() -> NumberRules.between(10, 5)).toThrow();
          });

          test("betweenExclusive with min >= max throws", () -> {
            expect(() -> NumberRules.betweenExclusive(5, 5)).toThrow();
            expect(() -> NumberRules.betweenExclusive(10, 5)).toThrow();
          });

          test("min with NaN throws", () -> {
            expect(() -> NumberRules.min(Double.NaN)).toThrow();
          });

          test("max with NaN throws", () -> {
            expect(() -> NumberRules.max(Double.NaN)).toThrow();
          });
        });

        describe("Integer primitive types", () -> {
          test("byte values", () -> {
            Rule<Number> rule = NumberRules.between(-128, 127);

            expect(rule.validate((byte) 0).isValid()).toBe(true);
            expect(rule.validate((byte) 127).isValid()).toBe(true);
            expect(rule.validate((byte) -128).isValid()).toBe(true);
          });

          test("short values", () -> {
            Rule<Number> rule = NumberRules.between(-32768, 32767);

            expect(rule.validate((short) 0).isValid()).toBe(true);
            expect(rule.validate((short) 32767).isValid()).toBe(true);
            expect(rule.validate((short) -32768).isValid()).toBe(true);
          });

          test("int values", () -> {
            Rule<Number> rule = NumberRules.positive();

            expect(rule.validate(42).isValid()).toBe(true);
            expect(rule.validate(Integer.MAX_VALUE).isValid()).toBe(true);
            expect(rule.validate(0).isInvalid()).toBe(true);
          });

          test("integer() with actual integers", () -> {
            Rule<Number> rule = NumberRules.integer();

            expect(rule.validate(42).isValid()).toBe(true);
            expect(rule.validate((long) 1000000).isValid()).toBe(true);
            expect(rule.validate((short) 100).isValid()).toBe(true);
          });
        });

        describe("Atomic number types", () -> {
          test("AtomicInteger", () -> {
            java.util.concurrent.atomic.AtomicInteger ai = new java.util.concurrent.atomic.AtomicInteger(42);

            expect(NumberRules.positive().validate(ai).isValid()).toBe(true);
            expect(NumberRules.between(0, 100).validate(ai).isValid()).toBe(true);
          });

          test("AtomicLong", () -> {
            java.util.concurrent.atomic.AtomicLong al = new java.util.concurrent.atomic.AtomicLong(100);

            expect(NumberRules.positive().validate(al).isValid()).toBe(true);
          });
        });

        describe("Rule composition", () -> {
          test("and() combines number rules", () -> {
            Rule<Number> rule = NumberRules.positive()
                .and(NumberRules.max(100))
                .and(NumberRules.integer());

            expect(rule.validate(50).isValid()).toBe(true);
            expect(rule.validate(50.5).isInvalid()).toBe(true);
            expect(rule.validate(-5).isInvalid()).toBe(true);
            expect(rule.validate(150).isInvalid()).toBe(true);
          });

          test("or() combines number rules", () -> {
            Rule<Number> rule = NumberRules.negative()
                .or(NumberRules.min(100));

            expect(rule.validate(-5).isValid()).toBe(true);
            expect(rule.validate(150).isValid()).toBe(true);
            expect(rule.validate(50).isInvalid()).toBe(true);
          });

          test("negate() inverts rule", () -> {
            Rule<Number> notPositive = NumberRules.positive().negate("must not be positive");

            expect(notPositive.validate(-5).isValid()).toBe(true);
            expect(notPositive.validate(0).isValid()).toBe(true);
            expect(notPositive.validate(5).isInvalid()).toBe(true);
            expect(notPositive.validate(5).message().orElse("")).toEqual("must not be positive");
          });

          test("compose() extracts number from object", () -> {
            Rule<Number> positiveRule = NumberRules.positive();
            Rule<String> rule = positiveRule.compose(Integer::parseInt);

            expect(rule.validate("42").isValid()).toBe(true);
            expect(rule.validate("-5").isInvalid()).toBe(true);
          });
        });

        describe("Singleton rules", () -> {
          test("finite() returns same instance", () -> {
            expect(NumberRules.finite() == NumberRules.finite()).toBe(true);
          });

          test("notNaN() returns same instance", () -> {
            expect(NumberRules.notNaN() == NumberRules.notNaN()).toBe(true);
          });

          test("isNaN() returns same instance", () -> {
            expect(NumberRules.isNaN() == NumberRules.isNaN()).toBe(true);
          });

          test("isInfinite() returns same instance", () -> {
            expect(NumberRules.isInfinite() == NumberRules.isInfinite()).toBe(true);
          });

          test("integer() returns same instance", () -> {
            expect(NumberRules.integer() == NumberRules.integer()).toBe(true);
          });

          test("positive() returns same instance", () -> {
            expect(NumberRules.positive() == NumberRules.positive()).toBe(true);
          });

          test("negative() returns same instance", () -> {
            expect(NumberRules.negative() == NumberRules.negative()).toBe(true);
          });

          test("nonNegative() returns same instance", () -> {
            expect(NumberRules.nonNegative() == NumberRules.nonNegative()).toBe(true);
          });

          test("nonPositive() returns same instance", () -> {
            expect(NumberRules.nonPositive() == NumberRules.nonPositive()).toBe(true);
          });
        });

        describe("integer() rule", () -> {
          test("accepts whole numbers", () -> {
            Rule<Number> rule = NumberRules.integer();

            expect(rule.validate(0.0).isValid()).toBe(true);
            expect(rule.validate(1.0).isValid()).toBe(true);
            expect(rule.validate(-1.0).isValid()).toBe(true);
            expect(rule.validate(1000000.0).isValid()).toBe(true);
          });

          test("rejects fractional numbers", () -> {
            Rule<Number> rule = NumberRules.integer();

            expect(rule.validate(0.5).isInvalid()).toBe(true);
            expect(rule.validate(1.1).isInvalid()).toBe(true);
            expect(rule.validate(-0.001).isInvalid()).toBe(true);
          });

          test("rejects NaN and Infinity", () -> {
            Rule<Number> rule = NumberRules.integer();

            expect(rule.validate(Double.NaN).isInvalid()).toBe(true);
            expect(rule.validate(Double.POSITIVE_INFINITY).isInvalid()).toBe(true);
            expect(rule.validate(Double.NEGATIVE_INFINITY).isInvalid()).toBe(true);
          });

          test("large integers", () -> {
            Rule<Number> rule = NumberRules.integer();

            // Note: large doubles may not represent integers exactly
            expect(rule.validate(1e10).isValid()).toBe(true);
          });
        });
      });
    });
  }
}