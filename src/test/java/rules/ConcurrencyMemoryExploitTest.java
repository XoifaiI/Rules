package rules;

import static testing.Testing.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.time.Duration;

public class ConcurrencyMemoryExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("Concurrency Exploits", () -> {

        describe("CON1 - Concurrent validation same context", () -> {
          test("timeout is per-validation, not shared", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(100))
                .build();

            AtomicBoolean slowTimedOut = new AtomicBoolean(false);
            AtomicBoolean fastCompleted = new AtomicBoolean(false);

            Thread slowThread = new Thread(() -> {
              List<Integer> list = new ArrayList<>();
              for (int i = 0; i < 100; i++) {
                list.add(i);
              }

              Rule<Integer> slowElementRule = v -> {
                try {
                  Thread.sleep(20); 
                } catch (InterruptedException e) {
                }
                return ValidationResult.valid();
              };

              try {
                @SuppressWarnings("unused")
                ValidationResult unused = ctx.validateTyped(
                    (Collection<Integer>) list,
                    CollectionRules.allMatch(slowElementRule));
              } catch (ValidationTimeoutException e) {
                slowTimedOut.set(true);
              }
            });

            Thread fastThread = new Thread(() -> {
              try {
                Thread.sleep(50);
              } catch (InterruptedException e) {
              }
              ValidationResult result = ctx.validateTyped("test", StringRules.notEmpty());
              if (result.isValid()) {
                fastCompleted.set(true);
              }
            });

            slowThread.start();
            fastThread.start();

            try {
              slowThread.join(1000);
              fastThread.join(1000);
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
            }

            expect(slowTimedOut.get()).toBe(true);
            expect(fastCompleted.get()).toBe(true);
          });
          test("multiple threads using same ValidationContext", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(100)
                .cycleDetection(true)
                .timeout(Duration.ofSeconds(5))
                .build();

            Rule<String> rule = CompositeRules.all(
                StringRules.notEmpty(),
                StringRules.minLength(1),
                StringRules.maxLength(100));

            int numThreads = 20;
            int iterationsPerThread = 100;
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(numThreads);
            AtomicInteger successCount = new AtomicInteger(0);
            AtomicInteger errorCount = new AtomicInteger(0);

            for (int t = 0; t < numThreads; t++) {
              final int threadId = t;
              new Thread(() -> {
                try {
                  startLatch.await();
                  for (int i = 0; i < iterationsPerThread; i++) {
                    String value = "thread" + threadId + "_iter" + i;
                    ValidationResult result = ctx.validateTyped(value, rule);
                    if (result.isValid()) {
                      successCount.incrementAndGet();
                    } else {
                      errorCount.incrementAndGet();
                    }
                  }
                } catch (Exception e) {
                  errorCount.incrementAndGet();
                } finally {
                  doneLatch.countDown();
                }
              }).start();
            }

            startLatch.countDown();
            doneLatch.await(10, TimeUnit.SECONDS);

            expect(successCount.get()).toBe(numThreads * iterationsPerThread);
            expect(errorCount.get()).toBe(0);
          });

          test("each validation gets independent state", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(5)
                .cycleDetection(true)
                .build();

            CountDownLatch bothStarted = new CountDownLatch(2);
            CountDownLatch canFinish = new CountDownLatch(1);
            AtomicReference<ValidationResult> result1 = new AtomicReference<>();
            AtomicReference<ValidationResult> result2 = new AtomicReference<>();

            Thread t1 = new Thread(() -> {
              List<Object> deep = new ArrayList<>();
              List<Object> current = deep;
              for (int i = 0; i < 10; i++) {
                List<Object> next = new ArrayList<>();
                current.add(next);
                current = next;
              }

              Rule<Object> recursiveRule = new Rule<Object>() {
                @Override
                public ValidationResult validate(Object value) {
                  return validateWithState(value, null);
                }

                @Override
                @SuppressWarnings("unchecked")
                public ValidationResult validateWithState(Object value, ValidationState state) {
                  if (value instanceof Collection) {
                    return CollectionRules.allMatch(this)
                        .validateWithState((Collection<Object>) value, state);
                  }
                  return ValidationResult.valid();
                }
              };

              bothStarted.countDown();
              try {
                canFinish.await(5, TimeUnit.SECONDS);
              } catch (InterruptedException e) {
              }

              result1.set(ctx.validateTyped(deep, CollectionRules.allMatch(recursiveRule)));
            });

            Thread t2 = new Thread(() -> {
              bothStarted.countDown();
              try {
                canFinish.await(5, TimeUnit.SECONDS);
              } catch (InterruptedException e) {
              }

              result2.set(ctx.validateTyped("hello", StringRules.notEmpty()));
            });

            t1.start();
            t2.start();

            bothStarted.await(1, TimeUnit.SECONDS);
            canFinish.countDown();

            t1.join(5000);
            t2.join(5000);

            expect(result1.get().isInvalid()).toBe(true);
            expect(result2.get().isValid()).toBe(true);
          });

          test("cycle detection array doesn't leak between validations", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxTrackedObjects(10)
                .build();

            List<Object> list1 = new ArrayList<>();
            list1.add("a");
            ctx.validateTyped(list1, CollectionRules.allMatch(v -> ValidationResult.valid()));

            List<Object> list2 = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
              list2.add("item" + i);
            }

            ValidationResult result = ctx.validateTyped(list2,
                CollectionRules.allMatch(v -> ValidationResult.valid()));
            expect(result.isValid()).toBe(true);
          });

          test("concurrent nested validation", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(50)
                .cycleDetection(true)
                .build();

            Rule<Object> recursiveRule = new Rule<Object>() {
              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validate(Object value) {
                if (value instanceof Collection<?>) {
                  return CollectionRules.allMatch(this).validate((Collection<Object>) value);
                }
                return ValidationResult.valid();
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection<?>) {
                  return CollectionRules.allMatch(this)
                      .validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.valid();
              }
            };

            int numThreads = 10;
            CountDownLatch latch = new CountDownLatch(numThreads);
            AtomicBoolean anyFailed = new AtomicBoolean(false);

            for (int t = 0; t < numThreads; t++) {
              new Thread(() -> {
                try {
                  List<Object> nested = new ArrayList<>();
                  List<Object> current = nested;
                  for (int i = 0; i < 10; i++) {
                    List<Object> next = new ArrayList<>();
                    current.add(next);
                    current = next;
                  }
                  current.add("leaf");

                  ValidationResult result = ctx.validateTyped(nested,
                      CollectionRules.allMatch(recursiveRule));

                  if (!result.isValid()) {
                    anyFailed.set(true);
                  }
                } catch (Exception e) {
                  anyFailed.set(true);
                } finally {
                  latch.countDown();
                }
              }).start();
            }

            latch.await(10, TimeUnit.SECONDS);
            expect(anyFailed.get()).toBe(false);
          });
        });

        describe("CON2 - Pattern cache race condition", () -> {
          test("concurrent pattern compilation", () -> {
            StringRules.clearPatternCache();

            int numThreads = 50;
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(numThreads);
            AtomicInteger successCount = new AtomicInteger(0);

            String pattern = "^test[0-9]+$";

            for (int t = 0; t < numThreads; t++) {
              new Thread(() -> {
                try {
                  startLatch.await();
                  Rule<String> rule = StringRules.matches(pattern);
                  if (rule.validate("test123").isValid()) {
                    successCount.incrementAndGet();
                  }
                } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
                } finally {
                  doneLatch.countDown();
                }
              }).start();
            }

            startLatch.countDown();
            doneLatch.await(10, TimeUnit.SECONDS);

            expect(successCount.get()).toBe(numThreads);
            expect(StringRules.patternCacheSize()).toBe(1);
          });

          test("patterns beyond cache limit still work", () -> {
            StringRules.clearPatternCache();

            for (int i = 0; i < 256; i++) {
              StringRules.matches("cached" + i).validate("test");
            }

            expect(StringRules.patternCacheSize()).toBe(256);

            Rule<String> uncached = StringRules.matches("^uncached[0-9]+$");
            expect(uncached.validate("uncached123").isValid()).toBe(true);
            expect(uncached.validate("invalid").isInvalid()).toBe(true);

            expect(StringRules.patternCacheSize()).toBe(256);
          });

          test("concurrent different patterns", () -> {
            StringRules.clearPatternCache();

            int numPatterns = 100;
            CountDownLatch latch = new CountDownLatch(numPatterns);
            AtomicInteger successCount = new AtomicInteger(0);

            for (int i = 0; i < numPatterns; i++) {
              final String pattern = "^pattern" + i + "$";
              final String input = "pattern" + i;
              new Thread(() -> {
                try {
                  Rule<String> rule = StringRules.matches(pattern);
                  if (rule.validate(input).isValid()) {
                    successCount.incrementAndGet();
                  }
                } finally {
                  latch.countDown();
                }
              }).start();
            }

            latch.await(10, TimeUnit.SECONDS);

            expect(successCount.get()).toBe(numPatterns);
            expect(StringRules.patternCacheSize() <= 256).toBe(true);
          });
        });

        describe("CON3 - CACHE_SIZE vs actual cache size", () -> {
          test("cache size tracking is accurate", () -> {
            StringRules.clearPatternCache();

            int expected = 0;
            for (int i = 0; i < 50; i++) {
              StringRules.matches("unique" + i).validate("test");
              expected++;
              expect(StringRules.patternCacheSize()).toBe(expected);
            }
          });

          test("cache size after clear", () -> {
            for (int i = 0; i < 10; i++) {
              StringRules.matches("temp" + i).validate("test");
            }

            StringRules.clearPatternCache();

            expect(StringRules.patternCacheSize()).toBe(0);
          });
        });

        describe("CON4 - Collection modified during iteration", () -> {
          test("ConcurrentHashMap is safe", () -> {
            Map<String, Integer> map = new ConcurrentHashMap<>();
            for (int i = 0; i < 100; i++) {
              map.put("key" + i, i);
            }

            CountDownLatch validationStarted = new CountDownLatch(1);
            CountDownLatch modificationDone = new CountDownLatch(1);
            AtomicReference<ValidationResult> resultRef = new AtomicReference<>();

            Thread validator = new Thread(() -> {
              Rule<Integer> slowRule = value -> {
                if (value == 0) {
                  validationStarted.countDown();
                  try {
                    modificationDone.await(1, TimeUnit.SECONDS);
                  } catch (InterruptedException e) {
                  }
                }
                return ValidationResult.valid();
              };

              ValidationResult result = CollectionRules.<String, Integer>allValues(slowRule)
                  .validate(map);
              resultRef.set(result);
            });

            validator.start();

            validationStarted.await(1, TimeUnit.SECONDS);

            map.put("newKey", 999);
            map.remove("key50");

            modificationDone.countDown();
            validator.join(2000);

            expect(resultRef.get() != null).toBe(true);
          });
        });
      });

      describe("Memory Exploits", () -> {

        describe("MEM1 - Pattern cache never cleared", () -> {
          test("cache is bounded at 256", () -> {
            StringRules.clearPatternCache();

            for (int i = 0; i < 300; i++) {
              StringRules.matches("pattern" + i).validate("test");
            }

            expect(StringRules.patternCacheSize() <= 256).toBe(true);
          });

          test("clearPatternCache() works", () -> {
            for (int i = 0; i < 50; i++) {
              StringRules.matches("p" + i).validate("test");
            }

            expect(StringRules.patternCacheSize() > 0).toBe(true);

            StringRules.clearPatternCache();

            expect(StringRules.patternCacheSize()).toBe(0);
          });
        });

        describe("MEM2 - ValidationState not cleaned up", () -> {
          test("state is cleaned after validation", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxDepth(100)
                .build();

            List<Object> nested = new ArrayList<>();
            List<Object> current = nested;
            for (int i = 0; i < 50; i++) {
              List<Object> next = new ArrayList<>();
              current.add(next);
              current = next;
            }

            Rule<Object> rule = new Rule<Object>() {
              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validate(Object value) {
                if (value instanceof Collection<?>) {
                  return CollectionRules.allMatch(this).validate((Collection<Object>) value);
                }
                return ValidationResult.valid();
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection<?>) {
                  return CollectionRules.allMatch(this)
                      .validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.valid();
              }
            };

            ctx.validateTyped(nested, rule);

            ValidationResult result2 = ctx.validateTyped(nested, rule);
            expect(result2.isValid()).toBe(true);
          });

          test("state cleaned even on exception", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .failSafe(true)
                .build();

            Rule<String> throwingRule = value -> {
              throw new RuntimeException("test");
            };

            ctx.validateTyped("test", throwingRule);

            ValidationResult result = ctx.validateTyped("test", StringRules.notEmpty());
            expect(result.isValid()).toBe(true);
          });
        });

        describe("MEM3 - Large error messages", () -> {
          test("large collection with many errors", () -> {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < 1000; i++) {
              list.add("");
            }

            Rule<Collection<String>> rule = CollectionRules.allMatch(
                StringRules.notEmpty());

            ValidationResult result = rule.validate(list);
            expect(result.isInvalid()).toBe(true);

            String msg = result.message().orElse("");
            expect(msg.length() < 1000).toBe(true);
          });
        });

        describe("MEM4 - Closure behavior", () -> {
          test("compose() works correctly with multiple invocations", () -> {
            Rule<Number> intRule = NumberRules.positive();
            Rule<String> composed = intRule.compose(Integer::parseInt);

            expect(composed.validate("42").isValid()).toBe(true);
            expect(composed.validate("100").isValid()).toBe(true);
            expect(composed.validate("-5").isInvalid()).toBe(true);
            expect(composed.validate("0").isInvalid()).toBe(true);
          });

          test("rule closures capture expected values correctly", () -> {
            String expected = "secret";
            Rule<String> rule = ObjectRules.secureEquals(expected);

            expect(rule.validate("secret").isValid()).toBe(true);
            expect(rule.validate("wrong").isInvalid()).toBe(true);
          });
        });
      });

      describe("Additional edge cases", () -> {
        test("validation in finally block", () -> {
          ValidationContext ctx = ValidationContext.builder().build();
          Rule<String> rule = StringRules.notEmpty();

          ValidationResult result = null;
          try {
            throw new RuntimeException("test");
          } catch (RuntimeException e) {
          } finally {
            result = ctx.validateTyped("hello", rule);
          }

          expect(result.isValid()).toBe(true);
        });

        test("recursive self-validation", () -> {
          ValidationContext ctx = ValidationContext.builder()
              .maxDepth(10)
              .build();

          AtomicInteger depth = new AtomicInteger(0);

          Rule<String> recursiveRule = new Rule<String>() {
            @Override
            public ValidationResult validate(String value) {
              int d = depth.incrementAndGet();
              if (d < 5) {
                return ctx.validateTyped(value, this);
              }
              return ValidationResult.valid();
            }
          };

          ValidationResult result = ctx.validateTyped("test", recursiveRule);
          expect(result.isValid()).toBe(true);
        });
        test("secureEqualsBytes defensive copy prevents mutation", () -> {
          byte[] original = new byte[] { 1, 2, 3, 4 };
          Rule<byte[]> rule = ObjectRules.secureEqualsBytes(original);

          original[0] = 99;

          expect(rule.validate(new byte[] { 1, 2, 3, 4 }).isValid()).toBe(true);
          expect(rule.validate(new byte[] { 99, 2, 3, 4 }).isInvalid()).toBe(true);
        });
        test("cleanup nulls out visited array", () -> {
          ValidationContext ctx = ValidationContext.builder()
              .cycleDetection(true)
              .build();

          List<Object> list = new ArrayList<>();
          for (int i = 0; i < 100; i++) {
            list.add(new Object());
          }

          ctx.validateTyped(list, CollectionRules.allMatch(v -> ValidationResult.valid()));

          for (int i = 0; i < 10; i++) {
            ValidationResult result = ctx.validateTyped(list,
                CollectionRules.allMatch(v -> ValidationResult.valid()));
            expect(result.isValid()).toBe(true);
          }
        });
      });
    });
  }
}