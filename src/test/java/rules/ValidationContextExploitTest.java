package rules;

import static testing.Testing.*;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class ValidationContextExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("ValidationContext/State Exploits", () -> {

        describe("VS1 - Exceed max depth", () -> {
          test("validate and validateTyped are equivalent", () -> {
            ValidationContext ctx = ValidationContext.builder().build();

            Rule<String> stringRule = StringRules.notEmpty();

            @SuppressWarnings("unchecked")
            Rule<Object> objectRule = (Rule<Object>) (Rule<?>) stringRule;

            ValidationResult typed = ctx.validateTyped("test", stringRule);
            ValidationResult untyped = ctx.validate("test", objectRule);

            expect(typed.isValid()).toBe(untyped.isValid());
          });

          test("nested structure deeper than maxDepth fails", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(5)
                .cycleDetection(false)
                .build();

            List<Object> root = createNestedList(10);

            Rule<Object> recursiveRule = createRecursiveRule();

            ValidationResult result = ctx.validateTyped(root, recursiveRule);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toContain("depth exceeded");
          });

          test("structure at exactly maxDepth passes", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(5)
                .cycleDetection(false)
                .build();

            List<Object> root = createNestedList(4);

            Rule<Object> recursiveRule = createRecursiveRule();

            ValidationResult result = ctx.validateTyped(root, recursiveRule);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("VS2 - Depth not decremented on exception", () -> {
          test("exception in rule still allows subsequent validations", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(10)
                .failSafe(true)
                .build();

            AtomicInteger exceptionCount = new AtomicInteger(0);

            Rule<Object> throwingRule = value -> {
              exceptionCount.incrementAndGet();
              throw new RuntimeException("Intentional exception");
            };

            for (int i = 0; i < 20; i++) {
              ctx.validateTyped("test", throwingRule);
            }

            expect(exceptionCount.get()).toBe(20);
          });
        });

        describe("VS3 - Timeout during iteration", () -> {
          test("timeout check happens during collection iteration", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(50))
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 1000; i++) {
              list.add(i);
            }

            AtomicInteger processed = new AtomicInteger(0);

            Rule<Number> slowRule = value -> {
              processed.incrementAndGet();
              try {
                Thread.sleep(10);
              } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
              }
              return ValidationResult.valid();
            };

            Rule<Collection<Number>> rule = CollectionRules.allMatch(slowRule);

            long start = System.currentTimeMillis();
            try {
              @SuppressWarnings({ "unchecked", "unused" })
              ValidationResult unused = ctx.validateTyped(
                  (Collection<Number>) (Collection<?>) list, rule);
            } catch (ValidationTimeoutException e) {
            }
            long elapsed = System.currentTimeMillis() - start;

            expect(processed.get() < 100).toBe(true);
            expect(elapsed < 200).toBe(true);
          });
        });

        describe("VS4 - Timeout edge cases", () -> {
          test("timeout with failSafe=true returns unavailable", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(50))
                .failSafe(true)
                .failSafeReturnsValid(false)
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
              list.add(i);
            }

            Rule<Integer> slowElementRule = v -> {
              try {
                Thread.sleep(10);
              } catch (InterruptedException e) {
              }
              return ValidationResult.valid();
            };

            ValidationResult result = ctx.validateTyped(
                (Collection<Integer>) list,
                CollectionRules.allMatch(slowElementRule));

            expect(result.isInvalid()).toBe(true);
          });

          test("timeout with failSafe=true and failSafeReturnsValid=true returns valid", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(50))
                .failSafe(true)
                .failSafeReturnsValid(true)
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
              list.add(i);
            }

            Rule<Integer> slowElementRule = v -> {
              try {
                Thread.sleep(10);
              } catch (InterruptedException e) {
              }
              return ValidationResult.valid();
            };

            ValidationResult result = ctx.validateTyped(
                (Collection<Integer>) list,
                CollectionRules.allMatch(slowElementRule));

            expect(result.isValid()).toBe(true);
          });

          test("very large timeout doesn't overflow", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofDays(365))
                .build();

            ValidationResult result = ctx.validateTyped("test", StringRules.notEmpty());
            expect(result.isValid()).toBe(true);
          });

          test("zero timeout means no timeout", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ZERO)
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
              list.add(i);
            }

            Rule<Collection<Number>> rule = CollectionRules.allMatch(NumberRules.nonNegative());

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped(
                (Collection<Number>) (Collection<?>) list, rule);
            expect(result.isValid()).toBe(true);
          });

          test("negative duration throws on build", () -> {
            expect(() -> ValidationContext.builder()
                .timeout(Duration.ofMillis(-100))
                .build()).toThrow();
          });
        });

        describe("VS5 - Cycle detection uses identity", () -> {
          test("cycleDetection=false allows actual cycles (until depth exceeded)", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(false)
                .maxDepth(10)
                .build();

            List<Object> selfRef = new ArrayList<>();
            selfRef.add(selfRef);

            Rule<Object> recursiveRule = createRecursiveRule();

            ValidationResult result = ctx.validateTyped(selfRef, recursiveRule);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toContain("depth exceeded");
          });

          test("equal but distinct objects are not detected as cycles", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .build();

            List<String> list1 = new ArrayList<>(Arrays.asList("a", "b", "c"));
            List<String> list2 = new ArrayList<>(Arrays.asList("a", "b", "c"));

            List<Object> container = new ArrayList<>();
            container.add(list1);
            container.add(list2);

            expect(list1.equals(list2)).toBe(true);
            expect(list1 == list2).toBe(false);

            Rule<Object> objRule = value -> ValidationResult.valid();
            Rule<Collection<Object>> rule = CollectionRules.allMatch(objRule);

            ValidationResult result = ctx.validateTyped(container, rule);
            expect(result.isValid()).toBe(true);
          });

          test("same object at same nesting level is not a cycle", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxDepth(10)
                .build();

            List<Object> shared = new ArrayList<>();
            shared.add("content");

            List<Object> container = new ArrayList<>();
            container.add(shared);
            container.add(shared);

            Rule<Object> objRule = value -> ValidationResult.valid();
            Rule<Collection<Object>> rule = CollectionRules.allMatch(objRule);

            ValidationResult result = ctx.validateTyped(container, rule);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("VS6 - Visited array growth", () -> {
          test("many unique objects tracked correctly", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxTrackedObjects(1000)
                .maxDepth(500)
                .build();

            List<Object> list = new ArrayList<>();
            for (int i = 0; i < 100; i++) {
              list.add(new Object());
            }

            Rule<Object> objRule = value -> ValidationResult.valid();
            Rule<Collection<Object>> rule = CollectionRules.allMatch(objRule);

            ValidationResult result = ctx.validateTyped(list, rule);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("VS7 - maxTrackedObjects exceeded", () -> {
          test("exceeding maxTrackedObjects fails validation", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxTrackedObjects(10)
                .maxDepth(100)
                .build();

            List<Object> root = createNestedList(20);

            Rule<Object> recursiveRule = createRecursiveRule();

            ValidationResult result = ctx.validateTyped(root, recursiveRule);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toContain("tracked objects exceeded");
          });
        });

        describe("VC1 - Builder validation", () -> {
          test("zero maxDepth throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxDepth(0)
                .build()).toThrow();
          });

          test("negative maxCollectionSize throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxCollectionSize(-1)
                .build()).toThrow();
          });

          test("zero maxCollectionSize throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxCollectionSize(0)
                .build()).toThrow();
          });
          test("null-returning rule in context returns invalid", () -> {
            ValidationContext ctx = ValidationContext.builder().build();

            Rule<String> nullRule = v -> null;

            ValidationResult result = ctx.validateTyped("test", nullRule);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("VC2 - Context immutability", () -> {
          test("context is immutable after build", () -> {
            ValidationContext.Builder builder = ValidationContext.builder()
                .maxDepth(10)
                .failSafe(false);

            ValidationContext ctx1 = builder.build();

            builder.maxDepth(100).failSafe(true);

            ValidationContext ctx2 = builder.build();

            expect(ctx1.validateTyped("test", StringRules.notEmpty()).isValid()).toBe(true);
            expect(ctx2.validateTyped("test", StringRules.notEmpty()).isValid()).toBe(true);
          });

          test("DEFAULT context has expected defaults", () -> {
            ValidationContext ctx = ValidationContext.DEFAULT;

            expect(ctx.maxDepth()).toBe(32);
            expect(ctx.maxCollectionSize()).toBe(10_000);
            expect(ctx.maxTrackedObjects()).toBe(1_000);
            expect(ctx.cycleDetection()).toBe(true);
            expect(ctx.detailedErrors()).toBe(false);
            expect(ctx.failSafe()).toBe(false);
            expect(ctx.failSafeReturnsValid()).toBe(false);
            expect(ctx.timeoutNanos()).toBe(0L);
          });
        });

        describe("VC3 - failSafe error handling", () -> {
          test("OutOfMemoryError in failSafe mode returns invalid", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .build();

            Rule<Object> oomRule = value -> {
              throw new OutOfMemoryError("Test OOM");
            };

            ValidationResult result = ctx.validateTyped("test", oomRule);
            expect(result.isInvalid()).toBe(true);
          });

          test("RuntimeException is caught and returns invalid", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .failSafeReturnsValid(false)
                .build();

            Rule<Object> throwingRule = value -> {
              throw new RuntimeException("Test exception");
            };

            ValidationResult result = ctx.validateTyped("test", throwingRule);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("VC4 - failSafeReturnsValid", () -> {
          test("failSafeReturnsValid=true returns valid on error", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .failSafeReturnsValid(true)
                .build();

            Rule<Object> throwingRule = value -> {
              throw new RuntimeException("Error");
            };

            ValidationResult result = ctx.validateTyped("test", throwingRule);
            expect(result.isValid()).toBe(true);
          });

          test("default failSafeReturnsValid is false", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .build();

            Rule<Object> throwingRule = value -> {
              throw new RuntimeException("Test");
            };

            ValidationResult result = ctx.validateTyped("test", throwingRule);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("VC5 - detailedErrors", () -> {
          test("detailedErrors=false hides sensitive info", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(false)
                .build();

            Rule<String> rule = value -> ValidationResult.invalid(ctx.errorMessage(
                "Secret: password123", "Validation failed"));

            ValidationResult result = ctx.validateTyped("test", rule);
            String msg = result.message().orElse("");

            expect(msg.contains("Secret")).toBe(false);
            expect(msg.contains("password")).toBe(false);
          });

          test("detailedErrors=true includes full message", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            Rule<String> rule = value -> ValidationResult.invalid(ctx.errorMessage(
                "Detailed: field 'email' is invalid", "Validation failed"));

            ValidationResult result = ctx.validateTyped("test", rule);
            String msg = result.message().orElse("");

            expect(msg.contains("Detailed")).toBe(true);
          });

          test("errorMessage(detailed) uses default generic", () -> {
            ValidationContext detailed = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            ValidationContext generic = ValidationContext.builder()
                .detailedErrors(false)
                .build();

            expect(detailed.errorMessage("specific error")).toEqual("specific error");
            expect(generic.errorMessage("specific error")).toEqual("Validation failed");
          });
        });

        describe("Thread safety", () -> {
          test("concurrent validation with same context", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(100)
                .cycleDetection(true)
                .build();

            Rule<String> rule = StringRules.notEmpty();

            List<Thread> threads = new ArrayList<>();
            AtomicInteger successCount = new AtomicInteger(0);
            AtomicInteger errorCount = new AtomicInteger(0);

            for (int i = 0; i < 10; i++) {
              threads.add(new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                  try {
                    ValidationResult result = ctx.validateTyped("test", rule);
                    if (result.isValid()) {
                      successCount.incrementAndGet();
                    }
                  } catch (Exception e) {
                    errorCount.incrementAndGet();
                  }
                }
              }));
            }

            threads.forEach(Thread::start);
            for (Thread thread : threads) {
              try {
                thread.join();
              } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
              }
            }

            expect(successCount.get()).toBe(1000);
            expect(errorCount.get()).toBe(0);
          });
        });

        describe("Builder minimum values", () -> {
          test("maxDepth minimum is 1", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(1)
                .build();

            expect(ctx.maxDepth()).toBe(1);
          });

          test("maxCollectionSize minimum is 1", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(1)
                .build();

            expect(ctx.maxCollectionSize()).toBe(1);
          });

          test("maxTrackedObjects minimum is 1", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxTrackedObjects(1)
                .build();

            expect(ctx.maxTrackedObjects()).toBe(1);
          });

          test("zero maxTrackedObjects throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxTrackedObjects(0)
                .build()).toThrow();
          });

          test("negative maxTrackedObjects throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxTrackedObjects(-1)
                .build()).toThrow();
          });

          test("negative maxDepth throws", () -> {
            expect(() -> ValidationContext.builder()
                .maxDepth(-1)
                .build()).toThrow();
          });

          test("null timeout throws NPE", () -> {
            expect(() -> ValidationContext.builder()
                .timeout(null)
                .build()).toThrow();
          });
        });

        describe("Collection size limits", () -> {
          test("collection at exactly maxCollectionSize passes", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(10)
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
              list.add(i);
            }

            Rule<Collection<Integer>> rule = CollectionRules.allMatch(v -> ValidationResult.valid());

            ValidationResult result = ctx.validateTyped(list, rule);
            expect(result.isValid()).toBe(true);
          });

          test("collection at maxCollectionSize+1 fails", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(10)
                .build();

            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < 11; i++) {
              list.add(i);
            }

            Rule<Collection<Integer>> rule = CollectionRules.allMatch(v -> ValidationResult.valid());

            ValidationResult result = ctx.validateTyped(list, rule);
            expect(result.isInvalid()).toBe(true);
            expect(result.isSystemError()).toBe(true);
          });
        });

        describe("Context accessor methods", () -> {
          test("all accessors return configured values", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(50)
                .maxCollectionSize(500)
                .maxTrackedObjects(100)
                .cycleDetection(false)
                .detailedErrors(true)
                .failSafe(true)
                .failSafeReturnsValid(true)
                .timeout(Duration.ofSeconds(5))
                .build();

            expect(ctx.maxDepth()).toBe(50);
            expect(ctx.maxCollectionSize()).toBe(500);
            expect(ctx.maxTrackedObjects()).toBe(100);
            expect(ctx.cycleDetection()).toBe(false);
            expect(ctx.detailedErrors()).toBe(true);
            expect(ctx.failSafe()).toBe(true);
            expect(ctx.failSafeReturnsValid()).toBe(true);
            expect(ctx.timeoutNanos()).toBe(5_000_000_000L);
          });
        });

        describe("Automatic state cleanup", () -> {
          test("repeated validations don't accumulate state", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxTrackedObjects(10)
                .build();

            for (int i = 0; i < 100; i++) {
              List<Object> list = new ArrayList<>();
              list.add(new Object());

              ValidationResult result = ctx.validateTyped(list,
                  CollectionRules.allMatch(v -> ValidationResult.valid()));
              expect(result.isValid()).toBe(true);
            }
          });

          test("state is cleaned after each validation", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(3)
                .build();

            for (int i = 0; i < 10; i++) {
              ValidationResult result = ctx.validateTyped("test", StringRules.notEmpty());
              expect(result.isValid()).toBe(true);
            }
          });
        });
      });
    });
  }

  private static List<Object> createNestedList(int depth) {
    List<Object> root = new ArrayList<>();
    List<Object> current = root;
    for (int i = 0; i < depth; i++) {
      List<Object> next = new ArrayList<>();
      current.add(next);
      current = next;
    }
    current.add("leaf");
    return root;
  }

  @SuppressWarnings("unchecked")
  private static Rule<Object> createRecursiveRule() {
    return new Rule<Object>() {
      @Override
      public ValidationResult validate(Object value) {
        if (value instanceof List<?>) {
          List<Object> list = (List<Object>) value;
          return CollectionRules.allMatch(this).validate(list);
        }
        return ValidationResult.valid();
      }

      @Override
      public ValidationResult validateWithState(Object value, ValidationState state) {
        if (value instanceof List<?>) {
          List<Object> list = (List<Object>) value;
          return CollectionRules.allMatch(this)
              .validateWithState(list, state);
        }
        return ValidationResult.valid();
      }
    };
  }
}