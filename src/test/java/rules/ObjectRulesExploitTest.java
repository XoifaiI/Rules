package rules;

import static testing.Testing.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class ObjectRulesExploitTest {

  enum TestEnum {
    A, B, C
  }

  enum OtherEnum {
    X, Y, Z
  }

  public static void main(String[] args) {
    entry(() -> {
      describe("ObjectRules Exploits", () -> {

        describe("O1 - secureEquals correctness with varying lengths", () -> {
          test("secureEquals validates correctly regardless of length", () -> {
            String secret = "secretpassword";
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate("a").isInvalid()).toBe(true);
            expect(rule.validate("secretp").isInvalid()).toBe(true);
            expect(rule.validate("secretpassword").isValid()).toBe(true);
            expect(rule.validate("secretpasswordx").isInvalid()).toBe(true);
            expect(rule.validate("wrongpassword!!").isInvalid()).toBe(true);
          });
        });

        describe("O2 - secureEquals correctness with different byte positions", () -> {
          test("secureEquals detects differences at any position", () -> {
            String secret = "abcdefghij";
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate("Xbcdefghij").isInvalid()).toBe(true);
            expect(rule.validate("abcdeXghij").isInvalid()).toBe(true);
            expect(rule.validate("abcdefghiX").isInvalid()).toBe(true);
            expect(rule.validate("abcdefghij").isValid()).toBe(true);
          });
        });

        describe("O3 - secureEquals with max length", () -> {
          test("exactly 1024 chars is accepted", () -> {
            String secret = "a".repeat(1024);
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate(secret).isValid()).toBe(true);
          });

          test("1025 char expected throws on construction", () -> {
            String tooLong = "a".repeat(1025);

            expect(() -> ObjectRules.secureEquals(tooLong)).toThrow();
          });

          test("1025 char input is rejected", () -> {
            String secret = "a".repeat(100);
            Rule<String> rule = ObjectRules.secureEquals(secret);

            String tooLongInput = "a".repeat(1025);
            ValidationResult result = rule.validate(tooLongInput);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value exceeds maximum length");
          });
        });

        describe("O3b - secureEqualsBytes with max length", () -> {
          test("exactly 1024 bytes is accepted", () -> {
            byte[] secret = new byte[1024];
            Arrays.fill(secret, (byte) 'a');
            Rule<byte[]> rule = ObjectRules.secureEqualsBytes(secret);

            expect(rule.validate(secret.clone()).isValid()).toBe(true);
          });

          test("1025 byte expected throws on construction", () -> {
            byte[] tooLong = new byte[1025];

            expect(() -> ObjectRules.secureEqualsBytes(tooLong)).toThrow();
          });

          test("1025 byte input is rejected", () -> {
            byte[] secret = new byte[100];
            Rule<byte[]> rule = ObjectRules.secureEqualsBytes(secret);

            byte[] tooLongInput = new byte[1025];
            ValidationResult result = rule.validate(tooLongInput);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value exceeds maximum length");
          });

          test("secureEquals rejects null input", () -> {
            Rule<String> rule = ObjectRules.secureEquals("secret");

            ValidationResult result = rule.validate(null);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value is null");
          });

          test("secureEqualsBytes rejects null input", () -> {
            Rule<byte[]> rule = ObjectRules.secureEqualsBytes("secret".getBytes());

            ValidationResult result = rule.validate(null);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value is null");
          });
        });

        describe("O5 - secureEquals basic functionality", () -> {
          test("secureEquals validates strings correctly", () -> {
            String secret = "abc";
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate("abc").isValid()).toBe(true);
            expect(rule.validate("ab").isInvalid()).toBe(true);
            expect(rule.validate("abcd").isInvalid()).toBe(true);
            expect(rule.validate("ABC").isInvalid()).toBe(true);
          });
        });

        describe("05b - secureEquals Unicode handling", () -> {
          test("secureEquals with multi-byte UTF-8 characters", () -> {
            String secret = "pÃ¤sswÃ¶rdâ„¢";
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate("pÃ¤sswÃ¶rdâ„¢").isValid()).toBe(true);
            expect(rule.validate("password").isInvalid()).toBe(true);
          });

          test("secureEquals with emoji", () -> {
            String secret = "passðŸ”‘word";
            Rule<String> rule = ObjectRules.secureEquals(secret);

            expect(rule.validate("passðŸ”‘word").isValid()).toBe(true);
            expect(rule.validate("passðŸ”word").isInvalid()).toBe(true);
          });

          test("secureEquals with combining characters", () -> {
            String single = "caf\u00E9";
            String combining = "cafe\u0301";

            Rule<String> rule = ObjectRules.secureEquals(single);

            expect(rule.validate(single).isValid()).toBe(true);
            expect(rule.validate(combining).isInvalid()).toBe(true);
          });
        });

        describe("O6 - instanceOf with null", () -> {
          test("instanceOf returns invalid for null", () -> {
            Rule<Object> rule = ObjectRules.instanceOf(String.class);

            ValidationResult result = rule.validate(null);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value is null");
          });
        });

        describe("O7 - instanceOf with subclass", () -> {
          test("instanceOf accepts subclasses", () -> {
            Rule<Object> rule = ObjectRules.instanceOf(Number.class);

            expect(rule.validate(Integer.valueOf(5)).isValid()).toBe(true);
            expect(rule.validate(Double.valueOf(5.0)).isValid()).toBe(true);
            expect(rule.validate(Long.valueOf(5L)).isValid()).toBe(true);
          });

          test("instanceOf accepts implementations of interfaces", () -> {
            Rule<Object> rule = ObjectRules.instanceOf(List.class);

            expect(rule.validate(new ArrayList<>()).isValid()).toBe(true);
            expect(rule.validate(new LinkedList<>()).isValid()).toBe(true);
          });

          test("instanceOf rejects unrelated types", () -> {
            Rule<Object> rule = ObjectRules.instanceOf(String.class);

            expect(rule.validate(Integer.valueOf(5)).isInvalid()).toBe(true);
          });
        });

        describe("O8 - instanceOf with primitives", () -> {
          test("primitive class vs wrapper class", () -> {
            Rule<Object> intRule = ObjectRules.instanceOf(int.class);
            Rule<Object> integerRule = ObjectRules.instanceOf(Integer.class);

            Integer boxed = 42;

            expect(intRule.validate(boxed).isInvalid()).toBe(true);
            expect(integerRule.validate(boxed).isValid()).toBe(true);
          });

          test("all primitive types", () -> {
            expect(ObjectRules.instanceOf(int.class).validate(42).isInvalid()).toBe(true);
            expect(ObjectRules.instanceOf(long.class).validate(42L).isInvalid()).toBe(true);
            expect(ObjectRules.instanceOf(double.class).validate(42.0).isInvalid()).toBe(true);
            expect(ObjectRules.instanceOf(boolean.class).validate(true).isInvalid()).toBe(true);
          });
        });

        describe("O9 - validEnum edge cases", () -> {
          test("validEnum accepts correct enum values", () -> {
            Rule<TestEnum> rule = ObjectRules.validEnum(TestEnum.class);

            expect(rule.validate(TestEnum.A).isValid()).toBe(true);
            expect(rule.validate(TestEnum.B).isValid()).toBe(true);
            expect(rule.validate(TestEnum.C).isValid()).toBe(true);
          });

          test("validEnum rejects null", () -> {
            Rule<TestEnum> rule = ObjectRules.validEnum(TestEnum.class);

            expect(rule.validate(null).isInvalid()).toBe(true);
          });

          test("validEnum rejects different enum type", () -> {
            @SuppressWarnings({ "unchecked", "rawtypes" })
            Rule<Enum> rule = (Rule<Enum>) (Rule<?>) ObjectRules.validEnum(TestEnum.class);

            Enum<?> wrongEnum = OtherEnum.X;
            expect(rule.validate(wrongEnum).isInvalid()).toBe(true);
          });
        });

        describe("O10 - equalTo with objects that throw", () -> {
          test("value with throwing equals()", () -> {
            Object thrower = new Object() {
              @Override
              public boolean equals(Object o) {
                throw new RuntimeException("equals() throws!");
              }

              @Override
              public int hashCode() {
                return 0;
              }
            };

            Rule<Object> rule = ObjectRules.equalTo(thrower);

            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .build();

            ValidationResult result = ctx.validateTyped("test", rule);
            expect(result.isInvalid()).toBe(true);
          });

          test("expected object with throwing equals()", () -> {
            Object thrower = new Object() {

              @Override
              public boolean equals(Object o) {
                throw new RuntimeException("equals() throws!");
              }

              @Override
              public int hashCode() {
                return 0;
              }
            };

            Rule<Object> rule = ObjectRules.equalTo(thrower);

            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .build();

            ValidationResult result = ctx.validateTyped("test", rule);

            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("O11 - equalTo with equals/hashCode mismatch", () -> {
          test("Objects.equals uses first arg's equals method", () -> {

            Object equalsAll = new Object() {
              @Override
              public boolean equals(Object o) {
                return true;
              }

              @Override
              public int hashCode() {
                return 0;
              }
            };

            Rule<Object> rule = ObjectRules.equalTo("expected");
            ValidationResult result = rule.validate(equalsAll);

            expect(result.isInvalid()).toBe(true);
          });

          test("object that never equals", () -> {
            Object neverEquals = new Object() {
              @Override
              public boolean equals(Object o) {
                return false;
              }

              @Override
              public int hashCode() {
                return 0;
              }
            };

            Rule<Object> rule = ObjectRules.equalTo(neverEquals);

            ValidationResult result = rule.validate(neverEquals);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("O12 - oneOf with mutable objects", () -> {
          test("mutable array elements are not cloned", () -> {
            StringBuilder sb = new StringBuilder("original");

            Rule<Object> rule = ObjectRules.oneOf(sb);

            expect(rule.validate(sb).isValid()).toBe(true);

            sb.append("modified");

            expect(rule.validate(sb).isValid()).toBe(true);
          });

          test("oneOf uses set contains - equality not identity", () -> {
            String a = new String("test");
            String b = new String("test");

            Rule<String> rule = ObjectRules.oneOf(a);

            expect(rule.validate(b).isValid()).toBe(true);
          });

          test("oneOf with array - array is copied", () -> {
            String[] allowed = { "a", "b", "c" };
            Rule<String> rule = ObjectRules.oneOf(allowed);

            allowed[0] = "x";

            expect(rule.validate("a").isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });
        });

        describe("O13 - oneOf with many values", () -> {
          test("oneOf with 10000 values works correctly", () -> {
            String[] allowed = new String[10000];
            for (int i = 0; i < 10000; i++) {
              allowed[i] = "value" + i;
            }

            Rule<String> rule = ObjectRules.oneOf(allowed);

            expect(rule.validate("value0").isValid()).toBe(true);
            expect(rule.validate("value5000").isValid()).toBe(true);
            expect(rule.validate("value9999").isValid()).toBe(true);
            expect(rule.validate("notallowed").isInvalid()).toBe(true);
            expect(rule.validate("value10000").isInvalid()).toBe(true);
          });

          test("oneOf with empty array rejects everything", () -> {
            Rule<String> rule = ObjectRules.oneOf();

            expect(rule.validate("anything").isInvalid()).toBe(true);
            expect(rule.validate("").isInvalid()).toBe(true);
          });

          test("oneOf with duplicates throws", () -> {
            expect(() -> ObjectRules.oneOf("a", "b", "a", "c", "b")).toThrow();
          });
        });

        describe("O14 - optional() double-wrapping", () -> {
          test("optional(optional(rule)) works correctly", () -> {
            Rule<String> inner = StringRules.notEmpty();
            Rule<String> opt1 = ObjectRules.optional(inner);
            Rule<String> opt2 = ObjectRules.optional(opt1);

            expect(opt2.validate(null).isValid()).toBe(true);
            expect(opt2.validate("hello").isValid()).toBe(true);
            expect(opt2.validate("").isInvalid()).toBe(true);
          });

          test("triple optional", () -> {
            Rule<String> rule = ObjectRules.optional(
                ObjectRules.optional(
                    ObjectRules.optional(
                        StringRules.notBlank())));

            expect(rule.validate(null).isValid()).toBe(true);
            expect(rule.validate("hello").isValid()).toBe(true);
            expect(rule.validate("   ").isInvalid()).toBe(true);
          });

          test("optional delegates to validateWithState", () -> {
            AtomicBoolean usedValidateWithState = new AtomicBoolean(false);

            Rule<String> trackingRule = new Rule<String>() {
              @Override
              public ValidationResult validate(String value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(String value, ValidationState state) {
                usedValidateWithState.set(true);
                return ValidationResult.valid();
              }
            };

            Rule<String> opt = ObjectRules.optional(trackingRule);

            ValidationContext ctx = ValidationContext.builder().build();

            usedValidateWithState.set(false);
            ValidationResult nullResult = ctx.validateTyped(null, opt);
            expect(nullResult.isValid()).toBe(true);
            expect(usedValidateWithState.get()).toBe(false);

            usedValidateWithState.set(false);
            ValidationResult nonNullResult = ctx.validateTyped("test", opt);
            expect(nonNullResult.isValid()).toBe(true);
            expect(usedValidateWithState.get()).toBe(true);
          });
        });

        describe("O15 - optional() with rule that accepts null", () -> {
          test("optional(isNull) - both pass for null", () -> {
            Rule<Object> isNull = ObjectRules.isNull();
            Rule<Object> optIsNull = ObjectRules.optional(isNull);

            expect(optIsNull.validate(null).isValid()).toBe(true);
            expect(optIsNull.validate("not null").isInvalid()).toBe(true);
          });

          test("optional wrapping alwaysValid", () -> {
            Rule<String> alwaysValid = Rule.alwaysValid();
            Rule<String> opt = ObjectRules.optional(alwaysValid);

            expect(opt.validate(null).isValid()).toBe(true);
            expect(opt.validate("anything").isValid()).toBe(true);
          });

          test("optional wrapping alwaysInvalid", () -> {
            Rule<String> alwaysInvalid = Rule.alwaysInvalid("always fails");
            Rule<String> opt = ObjectRules.optional(alwaysInvalid);

            expect(opt.validate(null).isValid()).toBe(true);
            expect(opt.validate("anything").isInvalid()).toBe(true);
          });
        });

        describe("Singleton rules", () -> {
          test("notNull returns same instance", () -> {
            expect(ObjectRules.notNull() == ObjectRules.notNull()).toBe(true);
          });

          test("isNull returns same instance", () -> {
            expect(ObjectRules.isNull() == ObjectRules.isNull()).toBe(true);
          });
        });

        describe("Null handling", () -> {
          test("notNull rejects null", () -> {
            expect(ObjectRules.notNull().validate(null).isInvalid()).toBe(true);
          });

          test("isNull accepts null", () -> {
            expect(ObjectRules.isNull().validate(null).isValid()).toBe(true);
          });

          test("isNull rejects non-null", () -> {
            expect(ObjectRules.isNull().validate("x").isInvalid()).toBe(true);
          });

          test("equalTo with null expected", () -> {
            Rule<Object> rule = ObjectRules.equalTo(null);

            expect(rule.validate(null).isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });

          test("equalTo uses Objects.equals semantics", () -> {
            List<String> expected = Arrays.asList("a", "b");
            List<String> actual = Arrays.asList("a", "b");

            Rule<Object> rule = ObjectRules.equalTo(expected);

            expect(rule.validate(actual).isValid()).toBe(true);
          });

          test("notEqualTo with null", () -> {
            Rule<Object> rule = ObjectRules.notEqualTo(null);

            expect(rule.validate(null).isInvalid()).toBe(true);
            expect(rule.validate("x").isValid()).toBe(true);
          });
        });

        describe("Constructor validation", () -> {
          test("instanceOf with null type throws", () -> {
            expect(() -> ObjectRules.instanceOf(null)).toThrow();
          });

          test("optional with null rule throws", () -> {
            expect(() -> ObjectRules.optional(null)).toThrow();
          });

          test("oneOf with null array throws", () -> {
            expect(() -> ObjectRules.oneOf((Object[]) null)).toThrow();
          });

          test("oneOf with null element throws", () -> {
            expect(() -> ObjectRules.oneOf("a", null, "c")).toThrow();
          });

          test("validEnum with null throws", () -> {
            expect(() -> ObjectRules.validEnum(null)).toThrow();
          });

          test("secureEquals with null throws", () -> {
            expect(() -> ObjectRules.secureEquals(null)).toThrow();
          });

          test("secureEqualsBytes with null throws", () -> {
            expect(() -> ObjectRules.secureEqualsBytes(null)).toThrow();
          });

          test("oneOf with duplicates throws", () -> {
            expect(() -> ObjectRules.oneOf("a", "b", "a")).toThrow();
          });
        });

        describe("Error messages", () -> {
          test("equalTo message", () -> {
            ValidationResult result = ObjectRules.equalTo("expected").validate("actual");
            expect(result.message().orElse("")).toEqual("Value does not equal expected");
          });

          test("notEqualTo message", () -> {
            ValidationResult result = ObjectRules.notEqualTo("x").validate("x");
            expect(result.message().orElse("")).toEqual("Value equals unexpected value");
          });

          test("notNull message", () -> {
            ValidationResult result = ObjectRules.notNull().validate(null);
            expect(result.message().orElse("")).toEqual("Value is null");
          });

          test("isNull message", () -> {
            ValidationResult result = ObjectRules.isNull().validate("x");
            expect(result.message().orElse("")).toEqual("Value is not null");
          });

          test("validEnum message", () -> {
            @SuppressWarnings({ "unchecked", "rawtypes" })
            Rule<Enum> rule = (Rule<Enum>) (Rule<?>) ObjectRules.validEnum(TestEnum.class);
            ValidationResult result = rule.validate(OtherEnum.X);
            expect(result.message().orElse("")).toEqual("Value is not a valid enum constant");
          });

          test("secureEquals mismatch message", () -> {
            ValidationResult result = ObjectRules.secureEquals("secret").validate("wrong");
            expect(result.message().orElse("")).toEqual("Value does not match");
          });

          test("secureEqualsBytes mismatch message", () -> {
            ValidationResult result = ObjectRules.secureEqualsBytes("secret".getBytes())
                .validate("wrong".getBytes());
            expect(result.message().orElse("")).toEqual("Value does not match");
          });
        });

        describe("Error message security", () -> {
          test("instanceOf does not reveal expected type", () -> {
            Rule<Object> rule = ObjectRules.instanceOf(String.class);

            ValidationResult result = rule.validate(42);
            String msg = result.message().orElse("");

            expect(msg.contains("String")).toBe(false);
            expect(msg).toEqual("Value is not of expected type");
          });

          test("oneOf does not reveal allowed values", () -> {
            Rule<String> rule = ObjectRules.oneOf("secret", "password", "token");

            ValidationResult result = rule.validate("wrong");
            String msg = result.message().orElse("");

            expect(msg.contains("secret")).toBe(false);
            expect(msg.contains("password")).toBe(false);
            expect(msg.contains("token")).toBe(false);
          });

          test("secureEquals does not reveal expected value", () -> {
            Rule<String> rule = ObjectRules.secureEquals("mysecret");

            ValidationResult result = rule.validate("wrong");
            String msg = result.message().orElse("");

            expect(msg.contains("mysecret")).toBe(false);
          });
        });
        describe("Rule composition", () -> {
          test("notNull and instanceOf", () -> {
            Rule<Object> rule = ObjectRules.notNull()
                .and(ObjectRules.instanceOf(String.class));

            expect(rule.validate(null).isInvalid()).toBe(true);
            expect(rule.validate(42).isInvalid()).toBe(true);
            expect(rule.validate("hello").isValid()).toBe(true);
          });

          test("isNull or equalTo", () -> {
            Rule<Object> rule = ObjectRules.isNull()
                .or(ObjectRules.equalTo("default"));

            expect(rule.validate(null).isValid()).toBe(true);
            expect(rule.validate("default").isValid()).toBe(true);
            expect(rule.validate("other").isInvalid()).toBe(true);
          });
        });
      });
    });
  }
}