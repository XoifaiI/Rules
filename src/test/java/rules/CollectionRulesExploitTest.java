package rules;

import static testing.Testing.*;

import java.time.Duration;
import java.util.*;
import java.util.concurrent.*;

public class CollectionRulesExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("CollectionRules Exploits", () -> {
        describe("C1 - Huge collection iteration", () -> {
          test("collection larger than maxCollectionSize should fail", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(100)
                .build();

            List<Integer> huge = new ArrayList<>();
            for (int i = 0; i < 101; i++) {
              huge.add(i);
            }

            var rule = CollectionRules.<Number>allMatch(
                NumberRules.positive());

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped((Collection<Number>) (Collection<?>) huge, rule);
            expect(result.isInvalid()).toBe(true);
          });

          test("collection at exactly maxCollectionSize should pass", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(100)
                .build();

            List<Integer> exact = new ArrayList<>();
            for (int i = 1; i <= 100; i++) {
              exact.add(i);
            }

            var rule = CollectionRules.<Number>allMatch(
                NumberRules.positive());

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped((Collection<Number>) (Collection<?>) exact, rule);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C2 - Lazy/infinite collection", () -> {
          test("collection with infinite iterator is stopped by timeout", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(50))
                .maxCollectionSize(Integer.MAX_VALUE)
                .build();

            Collection<Integer> infinite = new AbstractCollection<Integer>() {
              @Override
              public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {
                  private int i = 0;

                  @Override
                  public boolean hasNext() {
                    return true;
                  }

                  @Override
                  public Integer next() {
                    return i++;
                  }
                };
              }

              @Override
              public int size() {
                return Integer.MAX_VALUE;
              }
            };

            var rule = CollectionRules.<Number>allMatch(
                NumberRules.nonNegative());

            long start = System.currentTimeMillis();
            try {
              @SuppressWarnings("unchecked")
              ValidationResult result = ctx.validateTyped((Collection<Number>) (Collection<?>) infinite, rule);
              expect(result != null).toBe(true);
              expect(System.currentTimeMillis() - start < 200).toBe(true);
            } catch (ValidationTimeoutException e) {
              expect(System.currentTimeMillis() - start < 200).toBe(true);
            }
          });
        });

        describe("C3 - Collection that changes during iteration", () -> {
          test("ConcurrentModificationException is handled in failSafe mode", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .failSafe(true)
                .failSafeReturnsValid(false)
                .build();

            List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

            Rule<Number> evilRule = value -> {
              if (value.intValue() == 3) {
                list.clear();
                list.add(100);
                list.add(200);
              }
              return ValidationResult.valid();
            };

            var rule = CollectionRules.<Number>allMatch(evilRule);

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped(
                (Collection<Number>) (Collection<?>) list, rule);

            expect(result).toEqual(ValidationResult.unavailable());
          });
        });

        describe("C4 - Collection with slow size()", () -> {
          test("slow size() is called before iteration", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(1000)
                .timeout(Duration.ofMillis(100))
                .build();

            final int[] sizeCallCount = { 0 };

            Collection<Integer> slowSize = new AbstractCollection<Integer>() {
              private List<Integer> delegate = Arrays.asList(1, 2, 3);

              @Override
              public int size() {
                sizeCallCount[0]++;
                try {
                  Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                return delegate.size();
              }

              @Override
              public Iterator<Integer> iterator() {
                return delegate.iterator();
              }
            };

            var rule = CollectionRules.<Number>allMatch(
                NumberRules.positive());

            @SuppressWarnings({ "unchecked", "unused" })
            ValidationResult ignored = ctx.validateTyped((Collection<Number>) (Collection<?>) slowSize, rule);
            expect(sizeCallCount[0] >= 1).toBe(true);
          });
        });

        describe("C5 - Collection with slow iterator", () -> {
          test("slow iterator.next() is limited by timeout", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(Duration.ofMillis(100))
                .build();

            Collection<Integer> slowIterator = new AbstractCollection<Integer>() {
              @Override
              public int size() {
                return 10;
              }

              @Override
              public Iterator<Integer> iterator() {
                return new Iterator<Integer>() {
                  private int i = 0;

                  @Override
                  public boolean hasNext() {
                    return i < 10;
                  }

                  @Override
                  public Integer next() {
                    try {
                      Thread.sleep(50);
                    } catch (InterruptedException e) {
                    }
                    return i++;
                  }
                };
              }
            };

            var rule = CollectionRules.<Number>allMatch(
                NumberRules.nonNegative());

            long start = System.currentTimeMillis();
            try {
              @SuppressWarnings({ "unchecked", "unused" })
              ValidationResult ignored = ctx.validateTyped((Collection<Number>) (Collection<?>) slowIterator, rule);
            } catch (ValidationTimeoutException e) {
            }
            expect(System.currentTimeMillis() - start < 300).toBe(true);
          });
        });

        describe("C6 - Self-referential collection", () -> {
          test("list containing itself is detected", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .build();
            List<Object> list = new ArrayList<>();
            list.add("first");
            list.add(list);
            list.add("third");

            Rule<Object> objRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  return CollectionRules.allMatch(this).validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.valid();
              }
            };
            Rule<Collection<Object>> rule = CollectionRules.allMatch(objRule);

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped((Collection<Object>) (Collection<?>) list, rule);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Cyclic reference detected");
          });
        });

        describe("C7 - Indirect cycles", () -> {
          test("A contains B contains A is detected", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .build();

            List<Object> listA = new ArrayList<>();
            List<Object> listB = new ArrayList<>();

            listA.add("in A");
            listA.add(listB);

            listB.add("in B");
            listB.add(listA);

            @SuppressWarnings("unchecked")
            Rule<Object>[] objRuleHolder = new Rule[1];
            objRuleHolder[0] = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  @SuppressWarnings("unchecked")
                  Collection<Object> coll = (Collection<Object>) value;
                  return CollectionRules.allMatch(this).validateWithState(coll, state);
                }
                return ValidationResult.valid();
              }
            };
            Rule<Object> objRule = objRuleHolder[0];

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped((Collection<Object>) (Collection<?>) listA,
                CollectionRules.allMatch(objRule));
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("C8 - Cycle detection limit", () -> {
          test("maxTrackedObjects limits cycle detection", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxTrackedObjects(5)
                .maxDepth(100)
                .build();

            List<Object> root = new ArrayList<>();
            List<Object> current = root;
            for (int i = 0; i < 10; i++) {
              List<Object> next = new ArrayList<>();
              next.add("level " + i);
              current.add(next);
              current = next;
            }

            @SuppressWarnings("unchecked")
            Rule<Object>[] objRuleHolder = new Rule[1];
            objRuleHolder[0] = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  @SuppressWarnings("unchecked")
                  Collection<Object> coll = (Collection<Object>) value;
                  return CollectionRules.allMatch(this).validateWithState(coll, state);
                }
                return ValidationResult.valid();
              }
            };
            Rule<Object> objRule = objRuleHolder[0];

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped((Collection<Object>) (Collection<?>) root,
                CollectionRules.allMatch(objRule));
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toContain("tracked objects exceeded");
          });
        });

        describe("C9 - Identity vs equality confusion", () -> {
          test("same object appearing as sibling is not a cycle", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxDepth(10)
                .build();

            List<String> sharedList = new ArrayList<>(Arrays.asList("a", "b"));

            List<Object> container = new ArrayList<>();
            container.add(sharedList);
            container.add(sharedList);

            Rule<Object> recursiveRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  return CollectionRules.allMatch(this)
                      .validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.valid();
              }
            };

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped(
                (Collection<Object>) (Collection<?>) container,
                CollectionRules.allMatch(recursiveRule));

            expect(result.isValid()).toBe(true);
          });
        });

        describe("C10 - Empty collection with allMatch", () -> {
          test("allMatch on empty collection returns true (vacuous truth)", () -> {
            Rule<Collection<String>> rule = CollectionRules.allMatch(
                StringRules.notEmpty());

            ValidationResult result = rule.validate(Collections.emptyList());
            expect(result.isValid()).toBe(true);
          });

          test("allMatch with ctx on empty collection", () -> {
            ValidationContext ctx = ValidationContext.builder().build();

            Rule<Collection<String>> rule = CollectionRules.allMatch(
                StringRules.notEmpty());

            ValidationResult result = ctx.validateTyped(Collections.emptyList(), rule);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C11 - Empty collection with anyMatch", () -> {
          test("anyMatch on empty collection returns false", () -> {
            Rule<Collection<String>> rule = CollectionRules.anyMatch(
                StringRules.notEmpty());

            ValidationResult result = rule.validate(Collections.emptyList());
            expect(result.isInvalid()).toBe(true);
          });

          test("anyMatch with ctx on empty collection", () -> {
            ValidationContext ctx = ValidationContext.builder().build();

            Rule<Collection<String>> rule = CollectionRules.anyMatch(
                StringRules.notEmpty());

            ValidationResult result = ctx.validateTyped(Collections.emptyList(), rule);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("C12 - Null elements in collection", () -> {
          test("collection with null elements", () -> {
            List<String> list = Arrays.asList("a", null, "c");

            Rule<Collection<String>> rule = CollectionRules.allMatch(
                StringRules.notNull());

            ValidationResult result = rule.validate(list);
            expect(result.isInvalid()).toBe(true);
          });

          test("anyMatch with some nulls", () -> {
            List<String> list = Arrays.asList(null, "valid", null);

            Rule<Collection<String>> rule = CollectionRules.anyMatch(
                StringRules.notEmpty());

            ValidationResult result = rule.validate(list);
            expect(result.isValid()).toBe(true);
          });

          test("noneMatch with nulls", () -> {
            List<String> list = Arrays.asList(null, null, null);

            Rule<Collection<String>> rule = CollectionRules.noneMatch(
                StringRules.notNull());

            ValidationResult result = rule.validate(list);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C13 - Collection.contains() with null", () -> {
          test("contains(null) on list with null", () -> {
            List<String> list = Arrays.asList("a", null, "c");

            Rule<Collection<String>> rule = CollectionRules.contains(null);

            ValidationResult result = rule.validate(list);
            expect(result.isValid()).toBe(true);
          });

          test("contains(null) on list without null", () -> {
            List<String> list = Arrays.asList("a", "b", "c");

            Rule<Collection<String>> rule = CollectionRules.contains(null);

            ValidationResult result = rule.validate(list);
            expect(result.isInvalid()).toBe(true);
          });

          test("contains(null) on collection that doesn't support null", () -> {
            Set<String> set = new ConcurrentSkipListSet<>(Arrays.asList("a", "b"));

            Rule<Collection<String>> rule = CollectionRules.contains(null);

            ValidationResult result = rule.validate(set);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Collection does not contain element");
          });
        });

        describe("C14 - Map with null keys/values", () -> {
          test("map with null key", () -> {
            Map<String, Integer> map = new HashMap<>();
            map.put("a", 1);
            map.put(null, 2);
            map.put("c", 3);

            Rule<Map<String, Integer>> rule = CollectionRules.allKeys(
                StringRules.notNull());

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
          });

          test("map with null value", () -> {
            Map<String, Integer> map = new HashMap<>();
            map.put("a", 1);
            map.put("b", null);
            map.put("c", 3);

            @SuppressWarnings({ "unchecked", "rawtypes" })
            var rule = CollectionRules.<String, Integer>allValues(
                (Rule<Integer>) (Rule) ObjectRules.notNull());

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
          });

          test("containsKey with null", () -> {
            Map<String, Integer> map = new HashMap<>();
            map.put(null, 42);

            Rule<Map<String, Integer>> rule = CollectionRules.containsKey(null);

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C15 - Map iteration order", () -> {
          test("HashMap iteration order is non-deterministic", () -> {
            Map<String, Integer> map = new HashMap<>();
            for (int i = 0; i < 100; i++) {
              map.put("key" + i, i);
            }

            @SuppressWarnings({ "unchecked", "rawtypes" })
            var rule = CollectionRules.<String, Integer>allValues(
                (Rule<Integer>) (Rule) NumberRules.nonNegative());

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });

          test("LinkedHashMap preserves order", () -> {
            Map<String, Integer> map = new LinkedHashMap<>();
            map.put("first", 1);
            map.put("second", 2);
            map.put("third", 3);

            final List<String> order = new ArrayList<>();
            Rule<String> trackingRule = key -> {
              order.add(key);
              return ValidationResult.valid();
            };

            CollectionRules.<String, Integer>allKeys(trackingRule).validate(map);

            expect(order.get(0)).toEqual("first");
            expect(order.get(1)).toEqual("second");
            expect(order.get(2)).toEqual("third");
          });
        });

        describe("C16 - Map modified during validation", () -> {
          test("StructRule takes snapshot to prevent TOCTOU", () -> {
            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");
            map.put("age", 25);

            Rule<Object> evilRule = value -> {
              map.put("injected", "evil");
              return ValidationResult.valid();
            };

            StructRule<String, Object> struct = StructRule.<String, Object>builder()
                .field("name", evilRule)
                .field("age", evilRule)
                .strict()
                .build();

            Rule<Map<String, Object>> rule = struct.toRule();
            ValidationResult result = rule.validate(map);

            expect(map.containsKey("injected")).toBe(true);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C17 - Map with evil hashCode", () -> {
          test("keys with same hashCode cause collisions but still work", () -> {
            class EvilKey {
              final String name;

              EvilKey(String name) {
                this.name = name;
              }

              @Override
              public int hashCode() {
                return 42;
              }

              @Override
              public boolean equals(Object o) {
                return o instanceof EvilKey && ((EvilKey) o).name.equals(name);
              }
            }

            Map<EvilKey, Integer> map = new HashMap<>();
            for (int i = 0; i < 100; i++) {
              map.put(new EvilKey("key" + i), i);
            }

            @SuppressWarnings({ "unchecked", "rawtypes" })
            var rule = CollectionRules.<EvilKey, Integer>allValues(
                (Rule<Integer>) (Rule) NumberRules.nonNegative());

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("C18 - Map.get() returns null vs missing key", () -> {
          test("distinguishing null value from missing key", () -> {
            Map<String, Object> map = new HashMap<>();
            map.put("present", "value");
            map.put("nullValue", null);
            expect(map.containsKey("present")).toBe(true);
            expect(map.containsKey("nullValue")).toBe(true);
            expect(map.containsKey("missing")).toBe(false);

            expect(map.get("nullValue") == null).toBe(true);
            expect(map.get("missing") == null).toBe(true);
          });

          test("allValues validates null values", () -> {
            Map<String, String> map = new HashMap<>();
            map.put("a", "value");
            map.put("b", null);

            Rule<Map<String, String>> rule = CollectionRules.allValues(
                StringRules.notNull());

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("C19 - Element rule returns null", () -> {
          test("allMatch treats null result as invalid", () -> {
            Rule<String> nullRule = value -> null;
            Rule<Collection<String>> rule = CollectionRules.allMatch(nullRule);

            ValidationResult result = rule.validate(List.of("test"));
            expect(result.isInvalid()).toBe(true);
          });

          test("anyMatch treats null result as invalid (keeps searching)", () -> {
            Rule<String> nullRule = value -> null;
            Rule<Collection<String>> rule = CollectionRules.anyMatch(nullRule);

            ValidationResult result = rule.validate(List.of("a", "b", "c"));
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("No element matches");
          });

          test("noneMatch treats null result as invalid (not a match)", () -> {
            Rule<String> nullRule = value -> null;
            Rule<Collection<String>> rule = CollectionRules.noneMatch(nullRule);

            ValidationResult result = rule.validate(List.of("a", "b", "c"));
            expect(result.isValid()).toBe(true);
          });

          test("allKeys treats null result as invalid", () -> {
            Rule<String> nullRule = value -> null;
            Rule<Map<String, Integer>> rule = CollectionRules.allKeys(nullRule);

            ValidationResult result = rule.validate(Map.of("key", 1));
            expect(result.isInvalid()).toBe(true);
          });

          test("allValues treats null result as invalid", () -> {
            Rule<Integer> nullRule = value -> null;
            Rule<Map<String, Integer>> rule = CollectionRules.allValues(nullRule);

            ValidationResult result = rule.validate(Map.of("key", 1));
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("C20 - detailedErrors flag", () -> {
          test("allMatch shows detailed error when enabled", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            List<String> list = List.of("valid", "");

            ValidationResult result = ctx.validateTyped(list,
                CollectionRules.allMatch(StringRules.notEmpty()));

            expect(result.message().orElse("")).toContain("Element:");
          });

          test("allMatch shows generic error when disabled", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(false)
                .build();

            List<String> list = List.of("valid", "");

            ValidationResult result = ctx.validateTyped(list,
                CollectionRules.allMatch(StringRules.notEmpty()));

            expect(result.message().orElse("")).toEqual("Element validation failed");
          });

          test("allKeys shows detailed error when enabled", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            Map<String, Integer> map = Map.of("valid", 1, "", 2);

            ValidationResult result = ctx.validateTyped(map,
                CollectionRules.allKeys(StringRules.notEmpty()));

            expect(result.message().orElse("")).toContain("Key:");
          });

          test("allValues shows detailed error when enabled", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            Map<String, Integer> map = Map.of("a", 1, "b", -1);

            @SuppressWarnings({ "unchecked", "rawtypes" })
            ValidationResult result = ctx.validateTyped(map,
                CollectionRules.allValues((Rule) NumberRules.positive()));

            expect(result.message().orElse("")).toContain("Value:");
          });
        });

        describe("C21 - System error propagation", () -> {
          test("anyMatch propagates system error immediately", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(2)
                .build();

            List<List<List<String>>> nested = List.of(List.of(List.of("deep")));

            Rule<Object> recursiveRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  return CollectionRules.anyMatch(this)
                      .validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.invalid("no match");
              }
            };

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped(
                (Collection<Object>) (Collection<?>) nested,
                CollectionRules.anyMatch(recursiveRule));

            expect(result.isSystemError()).toBe(true);
          });

          test("noneMatch propagates system error immediately", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(2)
                .build();

            List<List<List<String>>> nested = List.of(List.of(List.of("deep")));

            Rule<Object> recursiveRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return validateWithState(value, null);
              }

              @Override
              @SuppressWarnings("unchecked")
              public ValidationResult validateWithState(Object value, ValidationState state) {
                if (value instanceof Collection) {
                  return CollectionRules.noneMatch(this)
                      .validateWithState((Collection<Object>) value, state);
                }
                return ValidationResult.invalid("no match");
              }
            };

            @SuppressWarnings("unchecked")
            ValidationResult result = ctx.validateTyped(
                (Collection<Object>) (Collection<?>) nested,
                CollectionRules.noneMatch(recursiveRule));

            expect(result.isSystemError()).toBe(true);
          });

          test("allKeys propagates system error", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(1)
                .build();

            Map<List<String>, Integer> map = Map.of(List.of("key"), 1);

            Rule<Object> depthExhaustingRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(Object value, ValidationState state) {
                ValidationResult scopeCheck = state.enterScope(value);
                if (scopeCheck.isInvalid()) {
                  return scopeCheck;
                }
                state.exitScope(value);
                return ValidationResult.valid();
              }
            };

            @SuppressWarnings({ "unchecked", "rawtypes" })
            ValidationResult result = ctx.validateTyped(map,
                CollectionRules.allKeys((Rule) depthExhaustingRule));

            expect(result.isSystemError()).toBe(true);
          });

          test("allValues propagates system error", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(1)
                .build();

            Map<String, List<Integer>> map = Map.of("key", List.of(1));

            Rule<Object> depthExhaustingRule = new Rule<Object>() {
              @Override
              public ValidationResult validate(Object value) {
                return ValidationResult.valid();
              }

              @Override
              public ValidationResult validateWithState(Object value, ValidationState state) {
                ValidationResult scopeCheck = state.enterScope(value);
                if (scopeCheck.isInvalid()) {
                  return scopeCheck;
                }
                state.exitScope(value);
                return ValidationResult.valid();
              }
            };

            @SuppressWarnings({ "unchecked", "rawtypes" })
            ValidationResult result = ctx.validateTyped(map,
                CollectionRules.allValues((Rule) depthExhaustingRule));

            expect(result.isSystemError()).toBe(true);
          });
        });

        describe("C22 - validate vs validateWithState consistency", () -> {
          test("allMatch without state behaves same as with default state", () -> {
            List<String> list = List.of("a", "b", "");

            Rule<Collection<String>> rule = CollectionRules.allMatch(StringRules.notEmpty());

            ValidationResult withoutState = rule.validate(list);
            ValidationResult withState = ValidationContext.DEFAULT.validateTyped(list, rule);

            expect(withoutState.isInvalid()).toBe(true);
            expect(withState.isInvalid()).toBe(true);
          });

          test("anyMatch without state behaves same as with default state", () -> {
            List<String> list = List.of("", "", "valid");

            Rule<Collection<String>> rule = CollectionRules.anyMatch(StringRules.notEmpty());

            ValidationResult withoutState = rule.validate(list);
            ValidationResult withState = ValidationContext.DEFAULT.validateTyped(list, rule);

            expect(withoutState.isValid()).toBe(true);
            expect(withState.isValid()).toBe(true);
          });
        });

        describe("C23 - Size boundary conditions", () -> {
          test("sizeBetween inclusive boundaries", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.sizeBetween(2, 4);

            expect(rule.validate(List.of(1)).isInvalid()).toBe(true);
            expect(rule.validate(List.of(1, 2)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3, 4)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3, 4, 5)).isInvalid()).toBe(true);
          });

          test("minSize boundary", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.minSize(3);

            expect(rule.validate(List.of(1, 2)).isInvalid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3, 4)).isValid()).toBe(true);
          });

          test("maxSize boundary", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.maxSize(3);

            expect(rule.validate(List.of(1, 2)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3)).isValid()).toBe(true);
            expect(rule.validate(List.of(1, 2, 3, 4)).isInvalid()).toBe(true);
          });

          test("size zero is valid for size(0)", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.size(0);

            expect(rule.validate(List.of()).isValid()).toBe(true);
            expect(rule.validate(List.of(1)).isInvalid()).toBe(true);
          });

          test("minSize zero accepts empty", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.minSize(0);

            expect(rule.validate(List.of()).isValid()).toBe(true);
          });

          test("sizeBetween zero to zero", () -> {
            Rule<Collection<Integer>> rule = CollectionRules.sizeBetween(0, 0);

            expect(rule.validate(List.of()).isValid()).toBe(true);
            expect(rule.validate(List.of(1)).isInvalid()).toBe(true);
          });
        });

        describe("Null handling", () -> {
          test("all collection rules reject null collection", () -> {
            expect(CollectionRules.notEmpty().validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.size(5).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.sizeBetween(1, 10).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.minSize(1).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.maxSize(10).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.allMatch(StringRules.notNull()).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.anyMatch(StringRules.notNull()).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.noneMatch(StringRules.notNull()).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.contains("x").validate(null).isInvalid()).toBe(true);
          });

          test("all map rules reject null map", () -> {
            expect(CollectionRules.mapNotEmpty().validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.mapSize(5).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.allKeys(StringRules.notNull()).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.allValues(ObjectRules.notNull()).validate(null).isInvalid()).toBe(true);
            expect(CollectionRules.containsKey("x").validate(null).isInvalid()).toBe(true);
          });
        });

        describe("Constructor validation", () -> {
          test("negative size throws", () -> {
            expect(() -> CollectionRules.size(-1)).toThrow();
          });

          test("negative minSize throws", () -> {
            expect(() -> CollectionRules.minSize(-1)).toThrow();
          });

          test("negative maxSize throws", () -> {
            expect(() -> CollectionRules.maxSize(-1)).toThrow();
          });

          test("negative mapSize throws", () -> {
            expect(() -> CollectionRules.mapSize(-1)).toThrow();
          });

          test("min > max in sizeBetween throws", () -> {
            expect(() -> CollectionRules.sizeBetween(10, 5)).toThrow();
          });

          test("negative bounds in sizeBetween throws", () -> {
            expect(() -> CollectionRules.sizeBetween(-1, 5)).toThrow();
            expect(() -> CollectionRules.sizeBetween(1, -5)).toThrow();
            expect(() -> CollectionRules.sizeBetween(-5, -1)).toThrow();
          });

          test("null element rule throws", () -> {
            expect(() -> CollectionRules.allMatch(null)).toThrow();
            expect(() -> CollectionRules.anyMatch(null)).toThrow();
            expect(() -> CollectionRules.noneMatch(null)).toThrow();
          });

          test("null key/value rule throws", () -> {
            expect(() -> CollectionRules.allKeys(null)).toThrow();
            expect(() -> CollectionRules.allValues(null)).toThrow();
          });

          test("containsKey(null) on TreeMap throws NPE but is handled", () -> {
            Map<String, Integer> map = new TreeMap<>();
            map.put("a", 1);

            Rule<Map<String, Integer>> rule = CollectionRules.containsKey(null);

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Required key not found");
          });
        });
      });
    });
  }
}