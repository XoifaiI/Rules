package rules;

import static testing.Testing.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HashDoSExploitTest {

    public static void main(String[] args) {
        entry(() -> {
            describe("HashDoS Attack Resistance", () -> {

                describe("String hashCode collision generation", () -> {
                    test("'Aa' and 'BB' have same hashCode", () -> {
                        expect("Aa".hashCode()).toBe("BB".hashCode());
                        expect("Aa".hashCode()).toBe(2112);
                    });

                    test("can generate arbitrary number of colliding strings", () -> {
                        List<String> collisions = generateCollidingStrings(1000);

                        int expectedHash = collisions.get(0).hashCode();
                        for (String s : collisions) {
                            expect(s.hashCode()).toBe(expectedHash);
                        }
                    });
                });

                describe("SecureHashMap collision resistance", () -> {
                    test("SecureHashMap distributes colliding keys across buckets", () -> {
                        List<String> collisions = generateCollidingStrings(1000);

                        int javaHash = collisions.get(0).hashCode();
                        for (String s : collisions) {
                            expect(s.hashCode()).toBe(javaHash);
                        }

                        SecureHashMap<String, Integer> secureMap = new SecureHashMap<>();
                        for (int i = 0; i < collisions.size(); i++) {
                            secureMap.put(collisions.get(i), i);
                        }

                        expect(secureMap.size()).toBe(1000);
                        for (int i = 0; i < collisions.size(); i++) {
                            expect(secureMap.get(collisions.get(i))).toBe(i);
                        }
                    });

                    test("SecureHashMap operations complete in reasonable time with colliding keys", () -> {
                        List<String> collisions = generateCollidingStrings(10000);

                        SecureHashMap<String, Integer> secureMap = new SecureHashMap<>();

                        long start = System.nanoTime();
                        for (int i = 0; i < collisions.size(); i++) {
                            secureMap.put(collisions.get(i), i);
                        }
                        long insertTime = System.nanoTime() - start;

                        start = System.nanoTime();
                        for (String key : collisions) {
                            secureMap.get(key);
                        }
                        long lookupTime = System.nanoTime() - start;

                        expect(insertTime < 100_000_000L).toBe(true);
                        expect(lookupTime < 100_000_000L).toBe(true);

                        System.out.println("SecureHashMap - Insert 10000 colliding keys: "
                                + (insertTime / 1_000_000) + "ms");
                        System.out.println("SecureHashMap - Lookup 10000 colliding keys: "
                                + (lookupTime / 1_000_000) + "ms");
                    });

                    test("different SecureHashMap instances have different hash functions", () -> {
                        SecureHashMap<String, Integer> map1 = new SecureHashMap<>();
                        SecureHashMap<String, Integer> map2 = new SecureHashMap<>();

                        map1.put("test", 1);
                        map2.put("test", 2);

                        expect(map1.get("test")).toBe(1);
                        expect(map2.get("test")).toBe(2);
                    });
                });

                describe("StructRule HashDoS resistance", () -> {
                    test("StructRule validation completes quickly with colliding keys", () -> {
                        List<String> collisions = generateCollidingStrings(5000);

                        Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                                .optionalField("expected_field", ObjectRules.notNull())
                                .build()
                                .toRule();

                        Map<String, Object> attackMap = new HashMap<>();
                        for (int i = 0; i < collisions.size(); i++) {
                            attackMap.put(collisions.get(i), "value" + i);
                        }

                        long start = System.nanoTime();
                        ValidationResult result = rule.validate(attackMap);
                        long elapsed = System.nanoTime() - start;

                        expect(result.isValid()).toBe(true);

                        expect(elapsed < 500_000_000L).toBe(true);

                        System.out.println("StructRule validation with 5000 colliding keys: "
                                + (elapsed / 1_000_000) + "ms");
                    });

                    test("strict mode with colliding keys still performs well", () -> {
                        List<String> collisions = generateCollidingStrings(1000);

                        StructRule.Builder<String, Object> builder = StructRule.builder();
                        for (int i = 0; i < 100; i++) {
                            builder.optionalField("field" + i, ObjectRules.notNull());
                        }
                        Rule<Map<String, Object>> rule = builder.strict().build().toRule();

                        Map<String, Object> attackMap = new HashMap<>();
                        for (String collision : collisions) {
                            attackMap.put(collision, "value");
                        }

                        long start = System.nanoTime();
                        ValidationResult result = rule.validate(attackMap);
                        long elapsed = System.nanoTime() - start;

                        expect(result.isInvalid()).toBe(true);
                        expect(elapsed < 100_000_000L).toBe(true);
                    });
                });

                describe("Comparison with vulnerable HashMap", () -> {
                    test("demonstrates performance difference with colliding keys", () -> {
                        List<String> collisions = generateCollidingStrings(2000);

                        Map<String, Integer> vulnerableMap = new HashMap<>();
                        long vulnerableStart = System.nanoTime();
                        for (int i = 0; i < collisions.size(); i++) {
                            vulnerableMap.put(collisions.get(i), i);
                        }
                        long vulnerableInsert = System.nanoTime() - vulnerableStart;

                        SecureHashMap<String, Integer> secureMap = new SecureHashMap<>();
                        long secureStart = System.nanoTime();
                        for (int i = 0; i < collisions.size(); i++) {
                            secureMap.put(collisions.get(i), i);
                        }
                        long secureInsert = System.nanoTime() - secureStart;

                        System.out.println("HashMap (vulnerable) - Insert " + collisions.size()
                                + " colliding keys: " + (vulnerableInsert / 1_000_000) + "ms");
                        System.out.println("SecureHashMap - Insert " + collisions.size()
                                + " colliding keys: " + (secureInsert / 1_000_000) + "ms");

                        expect(secureInsert < 100_000_000L).toBe(true);
                    });
                });

                describe("SecureHashMap basic operations", () -> {
                    test("put and get work correctly", () -> {
                        SecureHashMap<String, String> map = new SecureHashMap<>();

                        map.put("key1", "value1");
                        map.put("key2", "value2");

                        expect(map.get("key1")).toBe("value1");
                        expect(map.get("key2")).toBe("value2");
                        expect(map.get("key3")).toBe(null);
                    });

                    test("size and isEmpty", () -> {
                        SecureHashMap<String, Integer> map = new SecureHashMap<>();

                        expect(map.isEmpty()).toBe(true);
                        expect(map.size()).toBe(0);

                        map.put("a", 1);
                        expect(map.isEmpty()).toBe(false);
                        expect(map.size()).toBe(1);
                    });

                    test("containsKey", () -> {
                        SecureHashMap<String, String> map = new SecureHashMap<>();
                        map.put("exists", "value");

                        expect(map.containsKey("exists")).toBe(true);
                        expect(map.containsKey("missing")).toBe(false);
                    });

                    test("remove", () -> {
                        SecureHashMap<String, String> map = new SecureHashMap<>();
                        map.put("key", "value");

                        expect(map.remove("key")).toBe("value");
                        expect(map.containsKey("key")).toBe(false);
                        expect(map.remove("key")).toBe(null);
                    });

                    test("clear", () -> {
                        SecureHashMap<String, Integer> map = new SecureHashMap<>();
                        map.put("a", 1);
                        map.put("b", 2);

                        map.clear();

                        expect(map.isEmpty()).toBe(true);
                        expect(map.get("a")).toBe(null);
                    });

                    test("iteration via entrySet", () -> {
                        SecureHashMap<String, Integer> map = new SecureHashMap<>();
                        map.put("a", 1);
                        map.put("b", 2);
                        map.put("c", 3);

                        int count = 0;
                        int sum = 0;
                        for (Map.Entry<String, Integer> entry : map.entrySet()) {
                            count++;
                            sum += entry.getValue();
                        }

                        expect(count).toBe(3);
                        expect(sum).toBe(6);
                    });

                    test("copyOf creates independent copy", () -> {
                        Map<String, Integer> original = new HashMap<>();
                        original.put("key", 42);

                        SecureHashMap<String, Integer> copy = SecureHashMap.copyOf(original);

                        expect(copy.get("key")).toBe(42);

                        original.put("key", 100);
                        expect(copy.get("key")).toBe(42);
                    });

                    test("handles null values", () -> {
                        SecureHashMap<String, String> map = new SecureHashMap<>();
                        map.put("nullValue", null);

                        expect(map.containsKey("nullValue")).toBe(true);
                        expect(map.get("nullValue")).toBe(null);
                    });

                    test("update existing key", () -> {
                        SecureHashMap<String, String> map = new SecureHashMap<>();
                        map.put("key", "first");

                        String old = map.put("key", "second");

                        expect(old).toBe("first");
                        expect(map.get("key")).toBe("second");
                        expect(map.size()).toBe(1);
                    });
                });

                describe("SecureHashMap resizing", () -> {
                    test("handles growth beyond initial capacity", () -> {
                        SecureHashMap<String, Integer> map = new SecureHashMap<>(4);

                        for (int i = 0; i < 1000; i++) {
                            map.put("key" + i, i);
                        }

                        expect(map.size()).toBe(1000);

                        for (int i = 0; i < 1000; i++) {
                            expect(map.get("key" + i)).toBe(i);
                        }
                    });
                });
            });
        });
    }

    private static List<String> generateCollidingStrings(int count) {
        String[] bases = { "Aa", "BB" };

        List<String> result = new ArrayList<>();
        result.add("");

        while (result.size() < count) {
            List<String> expanded = new ArrayList<>();
            for (String existing : result) {
                for (String base : bases) {
                    expanded.add(existing + base);
                    if (expanded.size() >= count)
                        break;
                }
                if (expanded.size() >= count)
                    break;
            }
            result = expanded;
        }

        if (result.size() > count) {
            result = result.subList(0, count);
        }

        return result;
    }
}