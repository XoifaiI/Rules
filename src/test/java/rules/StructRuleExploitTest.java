package rules;

import static testing.Testing.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

public class StructRuleExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("StructRule Exploits", () -> {

        describe("ST1 - Missing required field", () -> {
          test("missing field fails validation", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> v != null
                    ? ValidationResult.valid()
                    : ValidationResult.invalid("name required"))
                .field("age", v -> v != null
                    ? ValidationResult.valid()
                    : ValidationResult.invalid("age required"))
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Required field missing");
          });

          test("all fields present passes", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .field("age", v -> ValidationResult.valid())
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");
            map.put("age", 30);

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("ST2 - Extra fields in strict mode", () -> {
          test("extra fields fail in strict mode", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .strict()
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");
            map.put("extra", "not allowed");

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toContain("Unexpected field");
          });

          test("no extra fields passes strict mode", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .strict()
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("ST3 - Extra fields in non-strict mode", () -> {
          test("extra fields allowed in non-strict mode", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");
            map.put("extra1", "allowed");
            map.put("extra2", "also allowed");

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("ST4 - Null value vs missing key", () -> {
          test("null value is different from missing key", () -> {
            AtomicBoolean fieldCalled = new AtomicBoolean(false);

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("maybeNull", v -> {
                  fieldCalled.set(true);
                  return v == null
                      ? ValidationResult.invalid("value is null")
                      : ValidationResult.valid();
                })
                .build()
                .toRule();

            Map<String, Object> mapWithNull = new HashMap<>();
            mapWithNull.put("maybeNull", null);

            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            ValidationResult result1 = ctx.validateTyped(mapWithNull, rule);
            expect(fieldCalled.get()).toBe(true);
            expect(result1.isInvalid()).toBe(true);
            expect(result1.message().orElse("")).toContain("value is null");
          });

          test("missing key also calls rule with null", () -> {
            AtomicBoolean fieldCalled = new AtomicBoolean(false);

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("required", v -> {
                  fieldCalled.set(true);
                  return v == null
                      ? ValidationResult.invalid("required is null")
                      : ValidationResult.valid();
                })
                .build()
                .toRule();

            Map<String, Object> emptyMap = new HashMap<>();

            ValidationResult result = rule.validate(emptyMap);
            expect(result.isInvalid()).toBe(true);
          });

          test("empty builder accepts any map", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .build()
                .toRule();

            Map<String, Object> emptyMap = new HashMap<>();
            Map<String, Object> fullMap = Map.of("a", 1, "b", 2);

            expect(rule.validate(emptyMap).isValid()).toBe(true);
            expect(rule.validate(fullMap).isValid()).toBe(true);
          });

          test("empty builder with strict rejects non-empty maps", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .strict()
                .build()
                .toRule();

            Map<String, Object> emptyMap = new HashMap<>();
            Map<String, Object> fullMap = Map.of("a", 1);

            expect(rule.validate(emptyMap).isValid()).toBe(true);
            expect(rule.validate(fullMap).isInvalid()).toBe(true);
          });
        });

        describe("ST5 - Duplicate field registration", () -> {
          test("duplicate field key throws on builder", () -> {
            expect(() -> StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .field("name", v -> ValidationResult.invalid("dup"))
                .build()).toThrow();
          });

          test("duplicate with optionalField also throws", () -> {
            expect(() -> StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .optionalField("name", v -> ValidationResult.valid())
                .build()).toThrow();
          });
        });

        describe("ST6 - Map modified during validation (TOCTOU)", () -> {
          test("snapshot protects against modification during validation", () -> {
            Map<String, Object> map = new HashMap<>();
            map.put("name", "Alice");
            map.put("status", "active");

            Rule<Object> modifyingRule = v -> {
              map.put("injected", "evil");
              return ValidationResult.valid();
            };

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", modifyingRule)
                .field("status", v -> ValidationResult.valid())
                .strict()
                .build()
                .toRule();

            ValidationResult result = rule.validate(map);

            expect(map.containsKey("injected")).toBe(true);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("ST7 - Map with delayed computation", () -> {
          test("map with side effects in get()", () -> {
            AtomicInteger accessCount = new AtomicInteger(0);

            Map<String, Object> countingMap = new HashMap<>() {
              @Override
              public Object get(Object key) {
                accessCount.incrementAndGet();
                return super.get(key);
              }
            };
            countingMap.put("field1", "value1");
            countingMap.put("field2", "value2");

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("field1", v -> ValidationResult.valid())
                .field("field2", v -> ValidationResult.valid())
                .build()
                .toRule();

            int before = accessCount.get();
            rule.validate(countingMap);
            int after = accessCount.get();

            expect(after == before).toBe(true);
          });
        });

        describe("ST8 - Snapshot bypass attempts", () -> {
          test("concurrent modification from another thread", () -> {
            Map<String, Object> map = new ConcurrentHashMap<>();
            map.put("field", "original");

            CountDownLatch validationStarted = new CountDownLatch(1);
            CountDownLatch modificationDone = new CountDownLatch(1);

            Rule<Object> slowRule = v -> {
              validationStarted.countDown();
              try {
                modificationDone.await(1, TimeUnit.SECONDS);
              } catch (InterruptedException e) {
              }
              return ValidationResult.valid();
            };

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("field", slowRule)
                .build()
                .toRule();

            CompletableFuture<ValidationResult> future = CompletableFuture.supplyAsync(() -> rule.validate(map));

            try {
              validationStarted.await(1, TimeUnit.SECONDS);

              map.put("field", "modified");
              map.put("injected", "evil");

              modificationDone.countDown();

              ValidationResult result = future.get(2, TimeUnit.SECONDS);

              expect(result.isValid()).toBe(true);
            } catch (Exception e) {
              fail("Test failed: " + e.getMessage());
            }
          });
        });

        describe("ST9 - Keys with broken equals/hashCode", () -> {
          test("keys with same hashCode work correctly", () -> {
            class EvilKey {
              final String name;

              EvilKey(String name) {
                this.name = name;
              }

              @Override
              public int hashCode() {
                return 42;
              }

              @Override
              public boolean equals(Object o) {
                return o instanceof EvilKey && ((EvilKey) o).name.equals(name);
              }

              @Override
              public String toString() {
                return name;
              }
            }

            Map<EvilKey, Object> map = new HashMap<>();
            EvilKey key1 = new EvilKey("field1");
            EvilKey key2 = new EvilKey("field2");
            map.put(key1, "value1");
            map.put(key2, "value2");

            Rule<Map<EvilKey, Object>> rule = StructRule.<EvilKey, Object>builder()
                .field(key1, v -> ValidationResult.valid())
                .field(key2, v -> ValidationResult.valid())
                .build()
                .toRule();

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });

          test("large map triggers collection size check", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxCollectionSize(5)
                .build();

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("a", v -> ValidationResult.valid())
                .build()
                .toRule();

            Map<String, Object> largeMap = new HashMap<>();
            for (int i = 0; i < 10; i++) {
              largeMap.put("key" + i, "value" + i);
            }

            ValidationResult result = ctx.validateTyped(largeMap, rule);
            expect(result.isInvalid()).toBe(true);
            expect(result.isSystemError()).toBe(true);
          });

          test("keys that never equal fail on field access", () -> {
            class NeverEqualKey {
              final String name;

              NeverEqualKey(String name) {
                this.name = name;
              }

              @Override
              public boolean equals(Object o) {
                return false;
              }

              @Override
              public int hashCode() {
                return name.hashCode();
              }

              @Override
              public String toString() {
                return name;
              }
            }

            Map<NeverEqualKey, Object> map = new HashMap<>();
            NeverEqualKey key = new NeverEqualKey("field");
            map.put(key, "value");

            Rule<Map<NeverEqualKey, Object>> rule = StructRule.<NeverEqualKey, Object>builder()
                .field(key, v -> ValidationResult.valid())
                .build()
                .toRule();

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });
        });

        describe("ST10 - Null keys", () -> {
          test("null key in field() throws", () -> {
            expect(() -> StructRule.<String, Object>builder()
                .field(null, v -> ValidationResult.valid())
                .build()).toThrow();
          });

          test("null key in optionalField() throws", () -> {
            expect(() -> StructRule.<String, Object>builder()
                .optionalField(null, v -> ValidationResult.valid())
                .build()).toThrow();
          });

          test("null-returning field rule treated as invalid", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("field", v -> null)
                .build()
                .toRule();

            Map<String, Object> map = Map.of("field", "value");

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Field validation failed");
          });

          test("map with null key in strict mode", () -> {
            Map<String, Object> map = new HashMap<>();
            map.put(null, "null key value");
            map.put("name", "Alice");

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .strict()
                .build()
                .toRule();

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("ST11 - Key toString() side effects", () -> {
          test("error message uses key toString()", () -> {
            class CustomKey {
              final String name;

              CustomKey(String name) {
                this.name = name;
              }

              @Override
              public String toString() {
                return "CustomKey[" + name + "]";
              }

              @Override
              public int hashCode() {
                return name.hashCode();
              }

              @Override
              public boolean equals(Object o) {
                return o instanceof CustomKey && ((CustomKey) o).name.equals(name);
              }
            }

            Map<CustomKey, Object> map = new HashMap<>();
            CustomKey key = new CustomKey("important");
            map.put(key, "badvalue");

            Rule<Map<CustomKey, Object>> rule = StructRule.<CustomKey, Object>builder()
                .field(key, v -> ValidationResult.invalid("validation failed"))
                .build()
                .toRule();

            ValidationContext ctx = ValidationContext.builder().detailedErrors(true).build();
            ValidationResult result = ctx.validateTyped(map, rule);
            String msg = result.message().orElse("");

            expect(msg.contains("CustomKey[important]")).toBe(true);
          });

          test("throwing toString() doesn't crash validation", () -> {
            class ThrowingKey {
              @Override
              public String toString() {
                throw new RuntimeException("toString() exploded!");
              }

              @Override
              public int hashCode() {
                return 42;
              }

              @Override
              public boolean equals(Object o) {
                return this == o;
              }
            }

            ThrowingKey key = new ThrowingKey();
            Map<ThrowingKey, Object> map = new HashMap<>();
            map.put(key, "value");

            expect(map.containsKey(key)).toBe(true);
          });
        });

        describe("ST12 - validateWithState behavior", () -> {
          test("respects depth limit", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .maxDepth(2)
                .build();

            Rule<Map<String, Object>> innerRule = StructRule.<String, Object>builder()
                .field("inner", v -> ValidationResult.valid())
                .build()
                .toRule();

            Rule<Map<String, Object>> outerRule = StructRule.<String, Object>builder()
                .field("nested", v -> {
                  @SuppressWarnings("unchecked")
                  Map<String, Object> nested = (Map<String, Object>) v;
                  return innerRule.validate(nested);
                })
                .build()
                .toRule();

            Map<String, Object> inner = Map.of("inner", "value");
            Map<String, Object> outer = Map.of("nested", inner);

            ValidationResult result = ctx.validateTyped(outer, outerRule);
            expect(result != null).toBe(true);
          });

          test("system error from field rule is propagated", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("field", v -> ValidationResult.systemError("depth exceeded"))
                .build()
                .toRule();

            ValidationContext ctx = ValidationContext.builder().build();
            ValidationResult result = ctx.validateTyped(Map.of("field", "value"), rule);

            expect(result.isInvalid()).toBe(true);
            expect(result.isSystemError()).toBe(true);
          });

          test("checks timeout between fields", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .timeout(java.time.Duration.ofMillis(50))
                .build();

            Rule<Object> slowRule = v -> {
              try {
                Thread.sleep(30);
              } catch (InterruptedException e) {
              }
              return ValidationResult.valid();
            };

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("field1", slowRule)
                .field("field2", slowRule)
                .field("field3", slowRule)
                .build()
                .toRule();

            Map<String, Object> map = Map.of("field1", 1, "field2", 2, "field3", 3);

            boolean timedOut = false;
            try {
              ctx.validateTyped(map, rule);
            } catch (ValidationTimeoutException e) {
              timedOut = true;
            }
            expect(timedOut).toBe(true);
          });

          test("cycle detection for self-referencing map", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .cycleDetection(true)
                .maxDepth(10)
                .build();

            Map<String, Object> selfRef = new HashMap<>();
            selfRef.put("self", selfRef);

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("self", v -> {
                  @SuppressWarnings({ "unchecked", "unused" })
                  Map<String, Object> nested = (Map<String, Object>) v;
                  return v == null ? ValidationResult.valid() : ValidationResult.valid();
                })
                .build()
                .toRule();

            ValidationResult result = ctx.validateTyped(selfRef, rule);
            expect(result != null).toBe(true);
          });

          test("toRule() called multiple times", () -> {
            StructRule<String, Object> struct = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .build();

            Rule<Map<String, Object>> rule1 = struct.toRule();
            Rule<Map<String, Object>> rule2 = struct.toRule();

            Map<String, Object> map = Map.of("name", "Alice");

            expect(rule1.validate(map).isValid()).toBe(true);
            expect(rule2.validate(map).isValid()).toBe(true);
          });

          test("builder.toRule() is equivalent to builder.build().toRule()", () -> {
            StructRule.Builder<String, Object> builder = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid());

            Rule<Map<String, Object>> rule1 = builder.toRule();
            Rule<Map<String, Object>> rule2 = builder.build().toRule();

            Map<String, Object> map = Map.of("name", "Alice");

            expect(rule1.validate(map).isValid()).toBe(true);
            expect(rule2.validate(map).isValid()).toBe(true);
          });
        });

        describe("Optional fields", () -> {
          test("optional field - missing is OK", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("required", v -> ValidationResult.valid())
                .optionalField("optional", v -> ValidationResult.valid())
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("required", "value");

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });

          test("optional field - present and valid", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .optionalField("optional",
                    v -> "good".equals(v) ? ValidationResult.valid() : ValidationResult.invalid("bad"))
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("optional", "good");

            ValidationResult result = rule.validate(map);
            expect(result.isValid()).toBe(true);
          });

          test("optional field - present and invalid", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .optionalField("optional",
                    v -> "good".equals(v) ? ValidationResult.valid() : ValidationResult.invalid("bad"))
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("optional", "not good");

            ValidationResult result = rule.validate(map);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("Error messages with detailedErrors flag", () -> {
          test("detailedErrors=false uses generic messages", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(false)
                .build();

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.invalid("name is bad"))
                .strict()
                .build()
                .toRule();

            Map<String, Object> map = Map.of("name", "value", "extra", "bad");

            ValidationResult result = ctx.validateTyped(map, rule);
            expect(result.message().orElse("")).toEqual("Unexpected field");
          });

          test("detailedErrors=true includes field name", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.invalid("name is bad"))
                .strict()
                .build()
                .toRule();

            Map<String, Object> mapWithExtra = Map.of("name", "value", "extra", "bad");
            ValidationResult extraResult = ctx.validateTyped(mapWithExtra, rule);
            expect(extraResult.message().orElse("").contains("extra")).toBe(true);

            Map<String, Object> mapBadName = Map.of("name", "bad");
            ValidationResult badResult = ctx.validateTyped(mapBadName, rule);
            expect(badResult.message().orElse("").contains("name")).toBe(true);
            expect(badResult.message().orElse("").contains("name is bad")).toBe(true);
          });

          test("fields are validated in definition order", () -> {
            List<String> order = new ArrayList<>();

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("first", v -> {
                  order.add("first");
                  return ValidationResult.valid();
                })
                .field("second", v -> {
                  order.add("second");
                  return ValidationResult.valid();
                })
                .field("third", v -> {
                  order.add("third");
                  return ValidationResult.valid();
                })
                .build()
                .toRule();

            Map<String, Object> map = new HashMap<>();
            map.put("third", 3);
            map.put("first", 1);
            map.put("second", 2);

            rule.validate(map);

            expect(order.size()).toBe(3);
            expect(order.get(0)).toEqual("first");
            expect(order.get(1)).toEqual("second");
            expect(order.get(2)).toEqual("third");
          });

          test("missing field message with detailedErrors", () -> {
            ValidationContext ctx = ValidationContext.builder()
                .detailedErrors(true)
                .build();

            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("required", v -> v == null
                    ? ValidationResult.invalid("required")
                    : ValidationResult.valid())
                .build()
                .toRule();

            ValidationResult result = ctx.validateTyped(Map.of(), rule);
            expect(result.message().orElse("").contains("required")).toBe(true);
          });
        });

        describe("Null handling", () -> {
          test("null map fails validation", () -> {
            Rule<Map<String, Object>> rule = StructRule.<String, Object>builder()
                .field("name", v -> ValidationResult.valid())
                .build()
                .toRule();

            ValidationResult result = rule.validate(null);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value is null");
          });

          test("null rule in field() throws", () -> {
            expect(() -> StructRule.<String, Object>builder()
                .field("name", null)
                .build()).toThrow();
          });
        });

        describe("Rule composition", () -> {
          test("struct rule with and()", () -> {
            Rule<Map<String, Object>> hasName = StructRule.<String, Object>builder()
                .field("name", v -> v != null ? ValidationResult.valid() : ValidationResult.invalid("no name"))
                .build()
                .toRule();

            Rule<Map<String, Object>> hasAge = StructRule.<String, Object>builder()
                .field("age", v -> v != null ? ValidationResult.valid() : ValidationResult.invalid("no age"))
                .build()
                .toRule();

            Rule<Map<String, Object>> combined = hasName.and(hasAge);

            expect(combined.validate(Map.of("name", "Alice", "age", 30)).isValid()).toBe(true);
            expect(combined.validate(Map.of("name", "Alice")).isInvalid()).toBe(true);
            expect(combined.validate(Map.of("age", 30)).isInvalid()).toBe(true);
          });
        });

        describe("Builder produces immutable struct", () -> {
          test("built StructRule is immutable", () -> {
            StructRule.Builder<String, Object> builder = StructRule.<String, Object>builder()
                .field("field1", v -> ValidationResult.valid());

            StructRule<String, Object> struct1 = builder.build();

            builder.field("field2", v -> v == null
                ? ValidationResult.invalid("field2 required")
                : ValidationResult.valid());

            StructRule<String, Object> struct2 = builder.build();

            Map<String, Object> mapBothFields = new HashMap<>();
            mapBothFields.put("field1", "value1");
            mapBothFields.put("field2", "value2");

            Rule<Map<String, Object>> rule1 = struct1.toRule();
            Rule<Map<String, Object>> rule2 = struct2.toRule();

            expect(rule1.validate(mapBothFields).isValid()).toBe(true);
            expect(rule2.validate(mapBothFields).isValid()).toBe(true);

            Map<String, Object> mapOnlyField1 = new HashMap<>();
            mapOnlyField1.put("field1", "value1");

            expect(rule1.validate(mapOnlyField1).isValid()).toBe(true);
            expect(rule2.validate(mapOnlyField1).isInvalid()).toBe(true);
          });
        });
      });
    });
  }

  private static void fail(String message) {
    throw new AssertionError(message);
  }
}