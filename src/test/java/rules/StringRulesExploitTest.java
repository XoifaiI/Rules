package rules;

import static testing.Testing.*;

public class StringRulesExploitTest {

  public static void main(String[] args) {
    entry(() -> {
      describe("StringRules Exploits", () -> {

        describe("S1 - ReDoS with evil regex", () -> {
          test("evil regex (a+)+ should complete quickly with RE2j", () -> {
            // This pattern causes catastrophic backtracking in java.util.regex
            // but RE2j handles it in linear time
            Rule<String> rule = StringRules.matches("(a+)+$");

            // This input would hang java.util.regex for hours
            String evilInput = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!";

            long start = System.nanoTime();
            ValidationResult result = rule.validate(evilInput);
            long elapsed = System.nanoTime() - start;

            // Should complete in under 100ms (RE2j is linear)
            expect(elapsed < 100_000_000L).toBe(true); // 100ms in nanos
            expect(result.isInvalid()).toBe(true);
          });

          test("nested quantifier (a|aa)+ should complete quickly", () -> {
            Rule<String> rule = StringRules.matches("^(a|aa)+$");
            String evilInput = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab";

            long start = System.nanoTime();
            ValidationResult result = rule.validate(evilInput);
            long elapsed = System.nanoTime() - start;

            expect(elapsed < 100_000_000L).toBe(true);
            expect(result.isInvalid()).toBe(true);
          });

          test("overlapping alternation ([a-zA-Z]+)* should complete quickly", () -> {
            Rule<String> rule = StringRules.matches("^([a-zA-Z]+)*$");
            String evilInput = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1";

            long start = System.nanoTime();
            ValidationResult result = rule.validate(evilInput);
            long elapsed = System.nanoTime() - start;

            expect(elapsed < 100_000_000L).toBe(true);
            expect(result.isInvalid()).toBe(true);
          });
        });

        describe("S2 - ReDoS with large pattern", () -> {
          test("very large regex pattern should still compile", () -> {
            // Create a large but valid pattern
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 10000; i++) {
              sb.append("a");
            }
            String largePattern = sb.toString();

            // Should compile without issue
            Rule<String> rule = StringRules.matches(largePattern);
            ValidationResult result = rule.validate(largePattern);
            expect(result.isValid()).toBe(true);
          });

          test("pattern with many alternations", () -> {
            // Pattern like (a|b|c|d|...|z) repeated
            StringBuilder sb = new StringBuilder();
            sb.append("^(");
            for (char c = 'a'; c <= 'z'; c++) {
              if (c > 'a')
                sb.append("|");
              sb.append(c);
            }
            sb.append(")+$");

            Rule<String> rule = StringRules.matches(sb.toString());
            ValidationResult result = rule.validate("abcxyz");
            expect(result.isValid()).toBe(true);
          });
        });

        describe("S3 - Pattern cache poisoning", () -> {
          test("cache fills up to MAX_CACHED_PATTERNS (256)", () -> {
            StringRules.clearPatternCache();

            // Fill cache with 256 patterns
            for (int i = 0; i < 256; i++) {
              StringRules.matches("pattern" + i).validate("test");
            }

            expect(StringRules.patternCacheSize()).toBe(256);
          });

          test("patterns beyond 256 don't increase cache size", () -> {
            StringRules.clearPatternCache();

            // Fill cache
            for (int i = 0; i < 300; i++) {
              StringRules.matches("unique" + i).validate("test");
            }

            // Cache should be capped at 256
            expect(StringRules.patternCacheSize()).toBe(256);
          });

          test("cached patterns still work correctly", () -> {
            StringRules.clearPatternCache();

            Rule<String> rule1 = StringRules.matches("^hello$");
            rule1.validate("hello"); // Cache it

            // Create 300 more patterns to potentially evict
            for (int i = 0; i < 300; i++) {
              StringRules.matches("other" + i).validate("test");
            }

            // Original pattern should still work
            // (may or may not be cached, but should work)
            Rule<String> rule2 = StringRules.matches("^hello$");
            expect(rule2.validate("hello").isValid()).toBe(true);
            expect(rule2.validate("world").isInvalid()).toBe(true);
          });

          test("same pattern string uses cached Pattern", () -> {
            StringRules.clearPatternCache();

            String regex = "^test[0-9]+$";
            Rule<String> rule1 = StringRules.matches(regex);
            Rule<String> rule2 = StringRules.matches(regex);

            // Both rules work correctly
            expect(rule1.validate("test123").isValid()).toBe(true);
            expect(rule2.validate("test123").isValid()).toBe(true);

            // Only one pattern should be cached
            expect(StringRules.patternCacheSize()).toBe(1);
          });
        });

        describe("S4 - Pattern cache memory exhaustion", () -> {
          test("large pattern strings as cache keys", () -> {
            StringRules.clearPatternCache();

            // Create patterns with large strings (but under limit)
            for (int i = 0; i < 10; i++) {
              String largePattern = "a".repeat(1000) + i;
              StringRules.matches(largePattern).validate("test");
            }

            // Should handle without OOM
            expect(StringRules.patternCacheSize() <= 256).toBe(true);
          });
        });

        describe("S5 - Regex input length boundary", () -> {
          test("input at exactly MAX_REGEX_INPUT_LENGTH (10000) should work", () -> {
            Rule<String> rule = StringRules.matches("^a+$");
            String input = "a".repeat(10000);

            ValidationResult result = rule.validate(input);
            expect(result.isValid()).toBe(true);
          });

          test("input at 10001 chars should fail", () -> {
            Rule<String> rule = StringRules.matches("^a+$");
            String input = "a".repeat(10001);

            ValidationResult result = rule.validate(input);
            expect(result.isInvalid()).toBe(true);
            expect(result.message().orElse("")).toEqual("Value exceeds maximum length");
          });

          test("matchesExactly also respects length limit", () -> {
            Rule<String> rule = StringRules.matchesExactly("^a+$");
            String input = "a".repeat(10001);

            ValidationResult result = rule.validate(input);
            expect(result.isInvalid()).toBe(true);
          });

          test("empty regex pattern matches everything", () -> {
            Rule<String> rule = StringRules.matches("");

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate("").isValid()).toBe(true);
          });

          test("matchesExactly empty pattern only matches empty string", () -> {
            Rule<String> rule = StringRules.matchesExactly("");

            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });
        });

        describe("S6 - Null byte injection", () -> {
          test("string with null byte is treated as single string", () -> {
            Rule<String> rule = StringRules.matches("^valid.*$");
            String input = "valid\0malicious";

            // Should match the entire string, not truncate at null
            ValidationResult result = rule.validate(input);
            expect(result.isValid()).toBe(true);
          });

          test("length counts null bytes", () -> {
            Rule<String> rule = StringRules.length(10);
            String input = "ab\0cd\0ef\0g"; // 10 chars including nulls

            expect(rule.validate(input).isValid()).toBe(true);
          });

          test("contains finds content after null byte", () -> {
            Rule<String> rule = StringRules.contains("malicious");
            String input = "valid\0malicious";

            expect(rule.validate(input).isValid()).toBe(true);
          });

          test("notEmpty with only null byte", () -> {
            Rule<String> rule = StringRules.notEmpty();
            String input = "\0";

            // Not empty - contains one character (null)
            expect(rule.validate(input).isValid()).toBe(true);
          });
        });

        describe("S7 - Unicode normalization attacks", () -> {
          test("precomposed vs decomposed characters", () -> {
            // √© as single char vs e + combining acute
            String precomposed = "caf\u00E9"; // caf√© (4 chars)
            String decomposed = "cafe\u0301"; // cafe + combining acute (5 chars)

            // These look the same but have different lengths
            Rule<String> rule4 = StringRules.length(4);
            Rule<String> rule5 = StringRules.length(5);

            expect(rule4.validate(precomposed).isValid()).toBe(true);
            expect(rule4.validate(decomposed).isInvalid()).toBe(true);
            expect(rule5.validate(decomposed).isValid()).toBe(true);
          });

          test("contains with normalized vs non-normalized", () -> {
            Rule<String> rule = StringRules.contains("√©"); // precomposed

            expect(rule.validate("caf√©").isValid()).toBe(true);
            // Decomposed won't match precomposed
            expect(rule.validate("cafe\u0301").isInvalid()).toBe(true);
          });

          test("regex matches normalized forms differently", () -> {
            Rule<String> rule = StringRules.matchesExactly("^caf.$");

            expect(rule.validate("caf√©").isValid()).toBe(true);
            // Decomposed has 5 chars so won't match
            expect(rule.validate("cafe\u0301").isInvalid()).toBe(true);
          });
        });

        describe("S8 - Unicode surrogate pairs", () -> {
          test("string with emoji (surrogate pair)", () -> {
            String emoji = "Hello üòÄ"; // üòÄ is a surrogate pair

            // length() returns code units, not code points
            // "Hello " = 6, üòÄ = 2 code units
            Rule<String> rule = StringRules.length(8);
            expect(rule.validate(emoji).isValid()).toBe(true);
          });

          test("unpaired high surrogate", () -> {
            String broken = "test\uD800"; // Unpaired high surrogate

            Rule<String> rule = StringRules.length(5);
            expect(rule.validate(broken).isValid()).toBe(true);
          });

          test("unpaired low surrogate", () -> {
            String broken = "test\uDC00"; // Unpaired low surrogate

            Rule<String> rule = StringRules.length(5);
            expect(rule.validate(broken).isValid()).toBe(true);
          });

          test("regex with surrogate pairs", () -> {
            Rule<String> rule = StringRules.matches("üòÄ");

            expect(rule.validate("Hello üòÄ World").isValid()).toBe(true);
          });

          test("family emoji (multiple code points)", () -> {
            // üë®‚Äçüë©‚Äçüëß‚Äçüë¶ = man + ZWJ + woman + ZWJ + girl + ZWJ + boy
            // Each person is a surrogate pair, ZWJ is single char
            String family = "üë®‚Äçüë©‚Äçüëß‚Äçüë¶";

            // This is 11 UTF-16 code units
            Rule<String> rule = StringRules.length(11);
            expect(rule.validate(family).isValid()).toBe(true);
          });
        });

        describe("S9 - Length with multi-byte chars", () -> {
          test("Chinese characters (BMP)", () -> {
            String chinese = "‰Ω†Â•Ω‰∏ñÁïå"; // 4 characters

            Rule<String> rule = StringRules.length(4);
            expect(rule.validate(chinese).isValid()).toBe(true);
          });

          test("mixed ASCII and emoji", () -> {
            String mixed = "AüòÄBüòÄC"; // A, üòÄ(2), B, üòÄ(2), C = 7 code units

            Rule<String> rule = StringRules.length(7);
            expect(rule.validate(mixed).isValid()).toBe(true);
          });

          test("lengthBetween with emojis", () -> {
            String emoji = "üéâüéäüéÅ"; // 3 emojis = 6 code units

            Rule<String> rule = StringRules.lengthBetween(5, 7);
            expect(rule.validate(emoji).isValid()).toBe(true);
          });

          test("lengthBetween rejects null", () -> {
            Rule<String> rule = StringRules.lengthBetween(1, 10);

            expect(rule.validate(null).isInvalid()).toBe(true);
            expect(rule.validate(null).message().orElse("")).toEqual("Value is null");
          });
        });

        describe("S10 - startsWith/endsWith empty string", () -> {
          test("startsWith empty string matches everything", () -> {
            Rule<String> rule = StringRules.startsWith("");

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("x").isValid()).toBe(true);
          });

          test("endsWith empty string matches everything", () -> {
            Rule<String> rule = StringRules.endsWith("");

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate("").isValid()).toBe(true);
          });

          test("contains empty string matches everything", () -> {
            Rule<String> rule = StringRules.contains("");

            expect(rule.validate("anything").isValid()).toBe(true);
            expect(rule.validate("").isValid()).toBe(true);
          });
        });

        describe("S11 - contains() with regex metacharacters", () -> {
          test("contains treats input as literal, not regex", () -> {
            Rule<String> rule = StringRules.contains(".*");

            // Should look for literal ".*", not match everything
            expect(rule.validate("test .* here").isValid()).toBe(true);
            expect(rule.validate("test").isInvalid()).toBe(true);
          });

          test("contains with special chars", () -> {
            Rule<String> rule = StringRules.contains("[a-z]+");

            expect(rule.validate("pattern: [a-z]+").isValid()).toBe(true);
            expect(rule.validate("abc").isInvalid()).toBe(true);
          });

          test("startsWith with regex metacharacters", () -> {
            Rule<String> rule = StringRules.startsWith("^start");

            expect(rule.validate("^start of line").isValid()).toBe(true);
            expect(rule.validate("start").isInvalid()).toBe(true);
          });
        });

        describe("S12 - UUID validation edge cases", () -> {
          test("valid UUID v4", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("550e8400-e29b-41d4-a716-446655440000").isValid()).toBe(true);
          });

          test("valid UUID v4 with braces", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("{550e8400-e29b-41d4-a716-446655440000}").isValid()).toBe(true);
          });

          test("UUID with wrong version (not 4)", () -> {
            Rule<String> rule = StringRules.uuidV4();

            // Version 1 UUID (first char of 3rd group should be 4)
            expect(rule.validate("550e8400-e29b-11d4-a716-446655440000").isInvalid()).toBe(true);
          });

          test("UUID with wrong variant", () -> {
            Rule<String> rule = StringRules.uuidV4();

            // Variant bits (first char of 4th group) should be 8, 9, a, or b
            expect(rule.validate("550e8400-e29b-41d4-0716-446655440000").isInvalid()).toBe(true);
            expect(rule.validate("550e8400-e29b-41d4-c716-446655440000").isInvalid()).toBe(true);
          });

          test("nil UUID", () -> {
            Rule<String> rule = StringRules.uuidV4();

            // Nil UUID has version 0, not 4
            expect(rule.validate("00000000-0000-0000-0000-000000000000").isInvalid()).toBe(true);
          });

          test("UUID all same digit variations", () -> {
            Rule<String> rule = StringRules.uuidV4();

            // Valid v4 with all 'a's where possible
            expect(rule.validate("aaaaaaaa-aaaa-4aaa-aaaa-aaaaaaaaaaaa").isValid()).toBe(true);
          });

          test("UUID uppercase vs lowercase", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("550E8400-E29B-41D4-A716-446655440000").isValid()).toBe(true);
            expect(rule.validate("550e8400-E29B-41d4-A716-446655440000").isValid()).toBe(true);
          });

          test("UUID too long", () -> {
            Rule<String> rule = StringRules.uuidV4();

            // Length > 38 rejected before regex
            expect(rule.validate("550e8400-e29b-41d4-a716-4466554400000").isInvalid()).toBe(true);
          });
        });

        describe("S13 - UUID with whitespace", () -> {
          test("UUID with leading space", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate(" 550e8400-e29b-41d4-a716-446655440000").isInvalid()).toBe(true);
          });

          test("UUID with trailing space", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("550e8400-e29b-41d4-a716-446655440000 ").isInvalid()).toBe(true);
          });

          test("UUID with newline", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("550e8400-e29b-41d4-a716-446655440000\n").isInvalid()).toBe(true);
          });

          test("UUID with internal space", () -> {
            Rule<String> rule = StringRules.uuidV4();

            expect(rule.validate("550e8400-e29b- 41d4-a716-446655440000").isInvalid()).toBe(true);
          });
        });

        describe("S14 - notBlank() with unusual whitespace", () -> {

          test("em space", () -> {
            Rule<String> rule = StringRules.notBlank();
            // Em space (U+2003) is whitespace
            expect(rule.validate("\u2003\u2003").isInvalid()).toBe(true);
          });

          test("non-breaking space", () -> {
            Rule<String> rule = StringRules.notBlank();
            // NBSP (U+00A0) isBlank() returns false for this in Java (it is NOT
            // whitespace for trim(), but isBlank()?)
            // Java 11 isBlank() uses Character.isWhitespace(codepoint).
            // NBSP is NOT whitespace in Java.
            // So notBlank() should be valid (not blank).
            expect(rule.validate("\u00A0").isValid()).toBe(true);
          });

          test("zero-width space", () -> {
            Rule<String> rule = StringRules.notBlank();
            // ZWS (U+200B) is NOT whitespace in Java.
            expect(rule.validate("\u200B").isValid()).toBe(true);
          });

          test("ideographic space", () -> {
            Rule<String> rule = StringRules.notBlank();

            // Ideographic space (U+3000) used in CJK
            expect(rule.validate("\u3000").isInvalid()).toBe(true);
          });

          test("mixed whitespace types", () -> {
            Rule<String> rule = StringRules.notBlank();

            // NBSP (U+00A0) is NOT whitespace per Character.isWhitespace()
            // so this string is NOT blank
            expect(rule.validate(" \t\n\r\u00A0\u2003").isValid()).toBe(true);
          });

          test("whitespace with one visible char", () -> {
            Rule<String> rule = StringRules.notBlank();

            expect(rule.validate("   x   ").isValid()).toBe(true);
          });
        });

        describe("S15 - Integer.MAX_VALUE as length", () -> {
          test("length(Integer.MAX_VALUE) creates valid rule", () -> {
            // Should not throw
            Rule<String> rule = StringRules.length(Integer.MAX_VALUE);

            // Any normal string won't match
            expect(rule.validate("test").isInvalid()).toBe(true);
          });

          test("maxLength(Integer.MAX_VALUE) allows all strings", () -> {
            Rule<String> rule = StringRules.maxLength(Integer.MAX_VALUE);

            expect(rule.validate("any string").isValid()).toBe(true);
            expect(rule.validate("a".repeat(10000)).isValid()).toBe(true);
          });

          test("minLength(Integer.MAX_VALUE) rejects all normal strings", () -> {
            Rule<String> rule = StringRules.minLength(Integer.MAX_VALUE);

            expect(rule.validate("test").isInvalid()).toBe(true);
          });
        });

        describe("S16 - lengthBetween with same min/max", () -> {
          test("lengthBetween(5, 5) is exact length", () -> {
            Rule<String> rule = StringRules.lengthBetween(5, 5);

            expect(rule.validate("12345").isValid()).toBe(true);
            expect(rule.validate("1234").isInvalid()).toBe(true);
            expect(rule.validate("123456").isInvalid()).toBe(true);
          });

          test("lengthBetween(0, 0) requires empty string", () -> {
            Rule<String> rule = StringRules.lengthBetween(0, 0);

            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });
        });

        describe("S17 - Zero length validation", () -> {
          test("length(0) requires empty string", () -> {
            Rule<String> rule = StringRules.length(0);

            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });

          test("minLength(0) allows all strings", () -> {
            Rule<String> rule = StringRules.minLength(0);

            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("anything").isValid()).toBe(true);
          });

          test("maxLength(0) requires empty string", () -> {
            Rule<String> rule = StringRules.maxLength(0);

            expect(rule.validate("").isValid()).toBe(true);
            expect(rule.validate("x").isInvalid()).toBe(true);
          });
        });

        describe("matches() vs matchesExactly()", () -> {
          test("matches() uses find() - partial match", () -> {
            Rule<String> rule = StringRules.matches("abc");

            expect(rule.validate("abc").isValid()).toBe(true);
            expect(rule.validate("xabcx").isValid()).toBe(true); // Contains abc
            expect(rule.validate("xyz").isInvalid()).toBe(true);
          });

          test("matchesExactly() uses matches() - full match", () -> {
            Rule<String> rule = StringRules.matchesExactly("abc");

            expect(rule.validate("abc").isValid()).toBe(true);
            expect(rule.validate("xabcx").isInvalid()).toBe(true); // Must be exact
            expect(rule.validate("xyz").isInvalid()).toBe(true);
          });

          test("matches() with anchors behaves like matchesExactly()", () -> {
            Rule<String> anchored = StringRules.matches("^abc$");
            Rule<String> exact = StringRules.matchesExactly("abc");

            expect(anchored.validate("abc").isValid()).toBe(true);
            expect(anchored.validate("xabcx").isInvalid()).toBe(true);

            expect(exact.validate("abc").isValid()).toBe(true);
            expect(exact.validate("xabcx").isInvalid()).toBe(true);
          });
        });

        describe("matchesPattern() behavior", () -> {
          test("matchesPattern uses provided pattern", () -> {
            com.google.re2j.Pattern pattern = com.google.re2j.Pattern.compile("^test$");
            Rule<String> rule = StringRules.matchesPattern(pattern);

            expect(rule.validate("test").isValid()).toBe(true);
            expect(rule.validate("testing").isInvalid()).toBe(true);
          });

          test("matchesPattern respects length limit", () -> {
            com.google.re2j.Pattern pattern = com.google.re2j.Pattern.compile("^a+$");
            Rule<String> rule = StringRules.matchesPattern(pattern);

            String tooLong = "a".repeat(10001);
            expect(rule.validate(tooLong).isInvalid()).toBe(true);
            expect(rule.validate(tooLong).message().orElse("")).toEqual("Value exceeds maximum length");
          });
        });

        describe("Error messages", () -> {
          test("notEmpty message", () -> {
            ValidationResult result = StringRules.notEmpty().validate("");
            expect(result.message().orElse("")).toEqual("Value is empty");
          });

          test("notBlank message", () -> {
            ValidationResult result = StringRules.notBlank().validate("   ");
            expect(result.message().orElse("")).toEqual("Value is blank");
          });

          test("length message", () -> {
            ValidationResult result = StringRules.length(5).validate("abc");
            expect(result.message().orElse("")).toEqual("Value length is incorrect");
          });

          test("lengthBetween message", () -> {
            ValidationResult result = StringRules.lengthBetween(5, 10).validate("abc");
            expect(result.message().orElse("")).toEqual("Value length is out of range");
          });

          test("minLength message", () -> {
            ValidationResult result = StringRules.minLength(5).validate("abc");
            expect(result.message().orElse("")).toEqual("Value is too short");
          });

          test("maxLength message", () -> {
            ValidationResult result = StringRules.maxLength(2).validate("abc");
            expect(result.message().orElse("")).toEqual("Value is too long");
          });

          test("matches message", () -> {
            ValidationResult result = StringRules.matches("^test$").validate("nope");
            expect(result.message().orElse("")).toEqual("Value does not match pattern");
          });

          test("startsWith message", () -> {
            ValidationResult result = StringRules.startsWith("hello").validate("goodbye");
            expect(result.message().orElse("")).toEqual("Value does not have expected prefix");
          });

          test("endsWith message", () -> {
            ValidationResult result = StringRules.endsWith("world").validate("hello");
            expect(result.message().orElse("")).toEqual("Value does not have expected suffix");
          });

          test("contains message", () -> {
            ValidationResult result = StringRules.contains("xyz").validate("abc");
            expect(result.message().orElse("")).toEqual("Value does not contain expected content");
          });

          test("uuidV4 message", () -> {
            ValidationResult result = StringRules.uuidV4().validate("not-a-uuid");
            expect(result.message().orElse("")).toEqual("Value is not a valid UUID v4");
          });
        });

        describe("Singleton rules", () -> {
          test("notNull returns same instance", () -> {
            expect(StringRules.notNull() == StringRules.notNull()).toBe(true);
          });

          test("notEmpty returns same instance", () -> {
            expect(StringRules.notEmpty() == StringRules.notEmpty()).toBe(true);
          });

          test("notBlank returns same instance", () -> {
            expect(StringRules.notBlank() == StringRules.notBlank()).toBe(true);
          });

          test("uuidV4 returns same instance", () -> {
            expect(StringRules.uuidV4() == StringRules.uuidV4()).toBe(true);
          });
        });

        describe("Rule composition", () -> {
          test("notEmpty and minLength", () -> {
            Rule<String> rule = StringRules.notEmpty()
                .and(StringRules.minLength(3));

            expect(rule.validate("").isInvalid()).toBe(true);
            expect(rule.validate("ab").isInvalid()).toBe(true);
            expect(rule.validate("abc").isValid()).toBe(true);
          });

          test("matches or startsWith", () -> {
            Rule<String> rule = StringRules.matches("^\\d+$")
                .or(StringRules.startsWith("ID:"));

            expect(rule.validate("12345").isValid()).toBe(true);
            expect(rule.validate("ID:abc").isValid()).toBe(true);
            expect(rule.validate("abc").isInvalid()).toBe(true);
          });

          test("negate notBlank to accept blank", () -> {
            Rule<String> isBlank = StringRules.notBlank().negate("must be blank");

            expect(isBlank.validate("").isValid()).toBe(true);
            expect(isBlank.validate("   ").isValid()).toBe(true);
            expect(isBlank.validate("x").isInvalid()).toBe(true);
          });
        });

        describe("Unicode in prefix/suffix/contains", () -> {
          test("startsWith with emoji", () -> {
            Rule<String> rule = StringRules.startsWith("üéâ");

            expect(rule.validate("üéâ Party!").isValid()).toBe(true);
            expect(rule.validate("Party üéâ").isInvalid()).toBe(true);
          });

          test("endsWith with Chinese", () -> {
            Rule<String> rule = StringRules.endsWith("‰∏ñÁïå");

            expect(rule.validate("‰Ω†Â•Ω‰∏ñÁïå").isValid()).toBe(true);
            expect(rule.validate("‰∏ñÁïå‰Ω†Â•Ω").isInvalid()).toBe(true);
          });

          test("contains with surrogate pair", () -> {
            Rule<String> rule = StringRules.contains("üòÄ");

            expect(rule.validate("Hello üòÄ World").isValid()).toBe(true);
            expect(rule.validate("No emoji here").isInvalid()).toBe(true);
          });
        });

        describe("Null handling", () -> {
          test("all rules reject null", () -> {
            expect(StringRules.notNull().validate(null).isInvalid()).toBe(true);
            expect(StringRules.notEmpty().validate(null).isInvalid()).toBe(true);
            expect(StringRules.notBlank().validate(null).isInvalid()).toBe(true);
            expect(StringRules.length(5).validate(null).isInvalid()).toBe(true);
            expect(StringRules.matches(".*").validate(null).isInvalid()).toBe(true);
            expect(StringRules.uuidV4().validate(null).isInvalid()).toBe(true);
            expect(StringRules.startsWith("x").validate(null).isInvalid()).toBe(true);
            expect(StringRules.endsWith("x").validate(null).isInvalid()).toBe(true);
            expect(StringRules.contains("x").validate(null).isInvalid()).toBe(true);
          });
        });

        describe("Constructor validation", () -> {
          test("negative length throws", () -> {
            expect(() -> StringRules.length(-1)).toThrow();
          });

          test("negative min length throws", () -> {
            expect(() -> StringRules.minLength(-1)).toThrow();
          });

          test("negative max length throws", () -> {
            expect(() -> StringRules.maxLength(-1)).toThrow();
          });

          test("negative lengthBetween min throws", () -> {
            expect(() -> StringRules.lengthBetween(-1, 10)).toThrow();
          });

          test("negative lengthBetween max throws", () -> {
            expect(() -> StringRules.lengthBetween(0, -1)).toThrow();
          });

          test("min > max throws", () -> {
            expect(() -> StringRules.lengthBetween(5, 3)).toThrow();
          });

          test("null regex throws", () -> {
            expect(() -> StringRules.matches(null)).toThrow();
          });

          test("null prefix throws", () -> {
            expect(() -> StringRules.startsWith(null)).toThrow();
          });

          test("null suffix throws", () -> {
            expect(() -> StringRules.endsWith(null)).toThrow();
          });

          test("null substring throws", () -> {
            expect(() -> StringRules.contains(null)).toThrow();
          });
          test("matchesPattern(null) throws", () -> {
            expect(() -> StringRules.matchesPattern(null)).toThrow();
          });
          test("matchesExactly(null) throws", () -> {
            expect(() -> StringRules.matchesExactly(null)).toThrow();
          });
          test("invalid regex throws on construction", () -> {
            // RE2j rejects some patterns that java.util.regex accepts
            // but basic invalid syntax should throw
            expect(() -> StringRules.matches("[")).toThrow();
          });

          test("matchesExactly with invalid regex throws", () -> {
            expect(() -> StringRules.matchesExactly("(unclosed")).toThrow();
          });
        });
      });
    });
  }
}
